#include <stdio.h>
#include <stdlib.h>
#include <TSystem.h>
#include <TROOT.h>
#include <TObjArray.h>
#include <TClassTable.h>
#include <TVectorT.h>
#include <TVector3.h>
#include <TLorentzVector.h>
#include <TMatrixD.h>
#include <TVectorD.h>
#include <TDatabasePDG.h>
#include <TParticlePDG.h>
#include <TStyle.h>
#include <TMath.h>
#include <TRandom3.h>
#include <TFile.h>
#include <TCanvas.h>
#include <TH1.h>
#include <TH2.h>
#include <TProfile.h>
#include <TF1.h>
#include <TTree.h>
#include <TBranch.h>
#include "TBrowser.h"
#include <TStopwatch.h>
#include "OpticEle.h"
#include "DriftEle.h"
#include "QuadEle.h"
#include "BendEle.h"

using namespace std;
const Double_t kPI =	 TMath::Pi();
const Double_t k2PI =	 TMath::TwoPi();
const Int_t kProton = 1;
const Int_t kNeutron = 0;

//define structure describing the geometry :
//x,y,z,hx,hy,z_thickness for every calorimeters: ZN1, ZN2, ZP1, ZP2, ZEM1, ZEM2
typedef struct {
  Double_t xczn[2];
  Double_t yczn[2];
  Double_t distn[2];
  Double_t hxzn[2];
  Double_t hyzn[2];
  Double_t thickzn[2];
  Double_t xczp[2];
  Double_t yczp[2];
  Double_t distp[2];
  Double_t hxzp[2];
  Double_t hyzp[2];
  Double_t thickzp[2];
  Double_t xczem[2];
  Double_t yczem[2];
  Double_t distem[2];
  Double_t hxzem[2];
  Double_t hyzem[2];
  Double_t thickzem[2];
} GEOM;
static GEOM geom;

//define structure for the initial beam parameters (vertex volume, divergence, crossing angle)
typedef struct IniBeamPar {
  Int_t ibeamfl;
  Double_t xbeam;
  Double_t dxbeam;
  Double_t ybeam;
  Double_t dybeam;
  Double_t zbeam;
  Double_t dzbeam;
  Double_t theta_div;
  Double_t BeamCrossAngle;
} INIBEAM;
static INIBEAM inibeam;

// define structure defining steering parameters (beam divergence, beam crossing
// angle, vertex volume, fermi momentum of spectator nucleons, removal 
// of fragments, background due to particles interacting in the trousers, new readout)
// the structure contains also the experimental resolution parameters
static struct steering_par {
 Int_t idgen;
 Int_t ifl_res;
 Int_t ifl_div;
 Int_t ifl_ip;
 Int_t ifl_cros;
 Int_t ifl_fermi;
 Int_t ifl_frag;
 Int_t ifl_bckgrnd;
 Int_t ifl_nf;
 Int_t ifl_newrdout;
 Int_t nevmax;
 Int_t nevfreq;
 Int_t nevfrst;
 Double_t Aproj;
 Double_t Zproj;
 Double_t Atarg;
 Double_t Ztarg;
 Double_t ebpern;
 Double_t sigmap;
 Double_t ZNhadSigmaRes[2];
 Double_t ZNemSigmaRes[2];
 Double_t ZPhadSigmaRes[2];
 Double_t ZPemSigmaRes[2];
 Double_t SigmaTOF;
 Double_t BaseLineMean;
 Double_t BaseLineSpread;
 char HIJ_Filename[80];
 char EMD_Filename[80];
 char OutTree_Filename[80];
} steer;

// the following two structures contain the particles kinematical variables
// generated by HIJING 
// common block /HMAIN1/ Nmul,EATT,JATT,NT,NP,N0,N01,N10,N11,B,psirp,NATT
static struct hij_eve1 {
 Int_t nmul; 
 Float_t eatt;
 Int_t jatt;
 Int_t nt;
 Int_t np;
 Int_t n0;
 Int_t n01;
 Int_t n10;
 Int_t n11;
 Float_t b;
 Float_t psirp;
 Int_t natt;
} ev1;
//  common block /HMAIN2/ KATT(MAXDIM,4),PATT(MAXDIM,4) 
static struct hij_eve2 {
 Int_t katt[2][130000];
 Float_t patt[4][130000];
} ev2;

// define structure to hold Fermi momentum distribution  
static struct FERMI{
  Double_t fProbInt_tp[201]; // Protons momentum distribution due to Fermi
  Double_t fProbInt_tn[201]; // Neutrons momentum distribution due to Fermi
  Double_t fPp[201]; // Spectator momenta
} fermi;

// define structures to hold output quantities from the program 
// divided in various branches
// input variables from event generators
typedef struct {
  Int_t idgene;
  Int_t nucparp;
  Int_t nucpart;
  Int_t prod_ptl;
  Int_t cons_ptl;
  Double_t bimp;
  Double_t psi_react_plane;
  Int_t nf[2];
  Int_t pf[2];
  Double_t vertex[3];
} GENE_T;
static GENE_T gene_t;

// energies released in neutron calorimeter (true value)
// according to the type of particle and the true centroid coordinates
typedef struct   {    // true energy released in ZN
  Double_t espnzn[2];  // spectator neutron energy
  Double_t eprnzn[2];  // participant neutron energy
  Double_t esppzn[2];  // spectator proton energy
  Double_t eprpzn[2];  // participant proton energy
  Double_t espfrzn[2]; // spectator nuclear fragment energy
  Double_t egamzn[2];  // gamma energy
  Double_t eothzn[2];  // other particle energy
  Double_t etruezn[2]; // total true energy in ZN
  Double_t xCentroidzn[2];  //true coord. x of centroid on ZN each event
  Double_t yCentroidzn[2];  //true coord. y of centroid on ZN each event
} ENZN_T;
static ENZN_T enzn_t;

// number of the different particles entering the neutron calorimeter 
typedef struct {
  Int_t spectnzn[2];  //number of neutron spectators in ZN
  Int_t partnzn[2];   //number of neutron participants in ZN
  Int_t spectpzn[2];  //number of proton spectators in ZN
  Int_t partpzn[2];   //numbeof proton participants in ZN
  Int_t fragzn[2];    //number of fragments in ZN
  Int_t gamzn[2];     //number of gammas in ZN
  Int_t othzn[2];     //number of other particles in ZN
} PTLZN_T;
static PTLZN_T ptlzn_t;
 
// energies released in proton calorimeter (true value)
// according to the type of particle 
typedef struct   {     // true energy released in ZP
  Double_t espnzp[2];  // spectator neutron energy
  Double_t eprnzp[2];  // participant neutron energy
  Double_t esppzp[2];  // spectator proton energy
  Double_t eprpzp[2];  // participant proton energy
  Double_t epiplzp[2]; // pion energy
  Double_t espfrzp[2]; // spectator nuclear fragment energy in ZP
  Double_t egamzp[2];  // gamma energy in ZP
  Double_t eothzp[2];  // other particle energy
  Double_t etruezp[2]; // total true energy in ZP
  Double_t xCentroidzp[2];  //true coord. x of centroid on ZP each event
  Double_t yCentroidzp[2];  //true coord. y of centroid on ZP each event
} ENZP_T;
static ENZP_T enzp_t;

// number of the different particles entering the proton calorimeter 
typedef struct {
  Int_t spectnzp[2];  //number of neutron spectators in ZP
  Int_t partnzp[2];   //number of neutron participants in ZP
  Int_t spectpzp[2];  //number of proton spectators in ZP
  Int_t partpzp[2];   //numbeof proton participants in ZP
  Int_t piplzp[2];    //number of pi plus in ZP
  Int_t fragzp[2];    //number of fragments in ZP
  Int_t gamzp[2];     //number of gammas in ZP
  Int_t othzp[2];     //number of other particles
} PTLZP_T;
static PTLZP_T ptlzp_t;

typedef struct   {    // true energy in ZEM
  Double_t egamzem[2];  //gamma energy in ZEM
  Double_t epizem[2];   //pion energy in ZEM 
  Double_t eprzem[2];   //proton energy in ZEM
  Double_t eneuzem[2];  //neutron energy in ZEM
} ENZEM_T;
static ENZEM_T enzem_t;
typedef struct {
  Int_t gamzem[2];  //number of gammas in ZEM
  Int_t pizem[2];   //number of pion in ZEM 
  Int_t przem[2];   //number of proton in ZEM
  Int_t neuzem[2];  //number of neutron in ZEM
} PTLZEM_T;
static PTLZEM_T ptlzem_t;

// define structure holding the experimental energies
// released in the calorimeters and the reconstructed centroid   
typedef struct {
  Double_t ezn[2];
  Double_t ezp[2];
  Double_t ezem[2];
  Double_t xreczn[2];
  Double_t yreczn[2];
  Double_t xreczp[2];
//  Double_t yreczp[2];
} ENEXP_T;
static ENEXP_T enexp_t;

// define structure containing the number of photoelectrons
// in each PMTs for all the hadronic calorimeters 
typedef struct {
  Int_t q1[2];  //phe in quadrant 1 of ZNs
  Int_t q2[2];  //phe in quadrant 2 of ZNs
  Int_t q3[2];  //phe in quadrant 3 of ZNs
  Int_t q4[2];  //phe in quadrant 4 of ZNs
  Int_t qc[2];  //phe in common PMT of ZNs
  Int_t t1[2];  //phe in tower 1 of ZPs
  Int_t t2[2];  //phe in tower 2 of ZPs
  Int_t t3[2];  //phe in tower 3 of ZPs
  Int_t t4[2];  //phe in tower 4 of ZPs
  Int_t tc[2];  //phe in common PMT of ZPs
} PHE_T;
static PHE_T phe_t;

// define structure containing the number of photoelectrons
// produced in the naked fibres 
typedef struct {
  Int_t q1nf[2];  //phe in quadrant 1 of ZNs
  Int_t q2nf[2];  //phe in quadrant 2 of ZNs
  Int_t q3nf[2];  //phe in quadrant 3 of ZNs
  Int_t q4nf[2];  //phe in quadrant 4 of ZNs
  Int_t qcnf[2];  //phe in common PMT of ZNs
  Int_t t1nf[2];  //phe in tower 1 of ZPs
  Int_t t2nf[2];  //phe in tower 2 of ZPs
  Int_t t3nf[2];  //phe in tower 3 of ZPs
  Int_t t4nf[2];  //phe in tower 4 of ZPs
  Int_t tcnf[2];  //phe in common PMT of ZPs
  Int_t xtq1[2];  //xtalk phe in quadrant 1 of ZNs
  Int_t xtq2[2];  //xtalk phe in quadrant 2 of ZNs
  Int_t xtq3[2];  //xtalk phe in quadrant 3 of ZNs
  Int_t xtq4[2];  //xtalk phe in quadrant 4 of ZNs
  Int_t xtqc[2];  //xtalk phe in common PMT of ZNs
  Int_t xtq1nf[2];  //xtalk phe in quadrant 1 of ZNs (nf)
  Int_t xtq2nf[2];  //xtalk phe in quadrant 2 of ZNs (nf)
  Int_t xtq3nf[2];  //xtalk phe in quadrant 3 of ZNs (nf)
  Int_t xtq4nf[2];  //xtalk phe in quadrant 4 of ZNs (nf)
  Int_t xtqcnf[2];  //xtalk phe in common PMT of ZNs (nf)
  Int_t xtt1[2];  //xtalk phe in tower 1 of ZPs
  Int_t xtt2[2];  //xtalk phe in tower 2 of ZPs
  Int_t xtt3[2];  //xtalk phe in tower 3 of ZPs
  Int_t xtt4[2];  //xtalk phe in tower 4 of ZPs
  Int_t xttc[2];  //xtalk phe in common PMT of ZPs
  Int_t xtt1nf[2];  //xtalk phe in tower 1 of ZPs (nf)
  Int_t xtt2nf[2];  //xtalk phe in tower 2 of ZPs (nf)
  Int_t xtt3nf[2];  //xtalk phe in tower 3 of ZPs (nf)
  Int_t xtt4nf[2];  //xtalk phe in tower 4 of ZPs (nf)
  Int_t xttcnf[2];  //xtalk phe in common PMT of ZPs (nf)
} PHENF_T;
static PHENF_T phenf_t;

typedef struct {
 Double_t Qx[2];
 Double_t Qy[2];
} FLOWVAR_T;
static FLOWVAR_T flowvar_t;

typedef struct {
  Float_t zn[24][5][2];
  Float_t zp[24][5][2];
  Float_t zem[24][2];
  Float_t Charge_ZN[2];
  Float_t Ampl_ZN[2];
  Float_t Time_ZN[2];
  Float_t SigmaTime_ZN[2];
  Float_t Charge_ZP[2];
  Float_t Ampl_ZP[2];
  Float_t Time_ZP[2];
  Float_t SigmaTime_ZP[2];
//  Float_t Charge_ZEM[2];
//  Float_t Ampl_ZEM[2];
//  Float_t Time_ZEM[2];
//  Float_t SigmaTime_ZEM[2];
} RAW_T;
static RAW_T raw_t;

typedef struct {
  Int_t EventNum;
  Int_t ParticleNum;
  Int_t ParticleCode;
  Int_t IdCalo;
  Int_t iSide;
  Int_t kacc;
  Double_t pvx;
  Double_t pvy;
  Double_t pvz;
  Double_t pv;
  Double_t xvrt;
  Double_t yvrt;
  Double_t zvrt;
  Double_t xcalo;
  Double_t ycalo;
  Double_t uxcalo;
  Double_t uycalo;
  Double_t Enecalo;
} ACC_T;
static ACC_T acc_t;

// define structure to hold line elements
typedef struct  {
  Int_t fNoElements; //number of elements of the line
//  TSortedList *fElements;
  TObjArray *fElements;
} MAGLIST;
static MAGLIST maglist;

typedef struct {
  Int_t num;
  char type[20][6];
  Double_t par[20][6];
} PAR_ELE;
static PAR_ELE par_ele;

// define structure to hold information of the
// current particle to be tracked in the setup 
typedef struct {
  Int_t kPDGcode;
  Double_t charge;
  Double_t Anucl;
  Double_t ZoverA;
  Bool_t partfl;
  Int_t iside;
  Int_t evnt;
  Int_t idcalo;
} CURRENT;
static CURRENT current;

//  global variables
///////////////////////////////////////////////////////////////////////////////

//TDatabasePDG *db;
TDatabasePDG *db   = TDatabasePDG::Instance();

// define matrix to calculate transverse shower for ZN (already inverted)
static const Double_t eleazn[9] = {0.5, 0.5, -0.5, -0.5, 0.5, 0.5, 0.5, -0.5, 0.5};
TMatrixD azn(3,3,eleazn);
// from ROOT fit on file nfull_fromip.root with option "S"
static const Double_t hpar_q1q3[4] = {0.500, 0.319, -3.22, -2.07e-03};
static const Double_t hpar_q1q2[4] = {0.500, 0.319, -3.21, -1.45e-03};
static const Double_t hpar_q2q3[4] = {0.498, 0.331, -1.76, -0.0198};
// from ROOT fit on file n0-4000flat.root+n2760_fromip.root with option "S"
//const Double_t hpar_q1q3[4] = {0.50,0.317,-3.3,0.0};
//const Double_t hpar_q1q2[4] = {0.50,0.317,-3.3,0.0};
//const Double_t hpar_q2q3[4] = {0.50,0.295,-2.1,0.0};
// from ROOT fit on file ezn_plane4.root with option "S"
//const Double_t epar_q1q3[4] = {0.50, 0.32, -9.6, 0.};
//const Double_t epar_q1q2[4] = {0.50, 0.32, -9.5, 0.};
//const Double_t epar_q2q3[4] = {0.50, 0.28, -5.2, 0.};
// parametrization of em particles
// from ROOT fit on file g0-4000_fromip_sidea.root with option "S"
//static const Double_t epar_q1q3[4] = {0.500, 0.324, -9.451, 0.};
//static const Double_t epar_q1q2[4] = {0.500, 0.324, -9.338, 0.};
//static const Double_t epar_q2q3[4] = {0.500, 0.331, -4.67, -0.026};
// from ROOT fit on file g0-4000_fromip.root with option "S"
const Double_t epar_q1q3[4] = {0.500, 0.324, -9.26, 0.};
const Double_t epar_q1q2[4] = {0.500, 0.324, -9.26, 0.};
const Double_t epar_q2q3[4] = {0.499, 0.340, -3.68, -0.026};

// define matrix (already inverted) and vectors for ZP
static const Double_t eleazp[9] = {1., 0., 0., -1., 1., 0., 0., -1., 1.};
TMatrixD azp(3,3,eleazp);
// from ROOT fit on file ~/fmc/truesidea/ptot.root with option "S"
const Double_t hpar_t1[4] = {0.491, 0.320, -1.58, 5.74};
const Double_t hpar_t1t2[4] = {0.500, 0.325, -1.41, 0.066};
const Double_t hpar_t1t2t3[4] = {0.508, 0.319, -1.62, -5.62};
// from ROOT fit on file egzp0-4000_flat.root with option "S"
const  Double_t epar_t1[4] = {0.5, 0.326, -4.32, 5.6};
const  Double_t epar_t1t2[4] = {0.5, 0.326, -4.24, 0.0};
const  Double_t epar_t1t2t3[4] = {0.5, 0.326, -4.31, -5.6};
// define files used in many functions
FILE *fev;  //file containing the HIJING event
//FILE *fout;  //file containing the some useful variables for acceptance calc
//  variables to contain single emd event
TFile *femd; //file containing the single emd ntuples
TTree *h2034;
Int_t nmul,pmul;
Float_t npx[100],npy[100],npz[100],ppx[100],ppy[100],ppz[100];
// function to calculate energy in ZP when ifl_bckgrnd = 1
TF1 *fbckg1ZP = new TF1("fbckg1ZP","gaus(0)+gaus(3)",0.,1.);
// function to calculate energy in ZN when ifl_bckgrnd = 1
TF1 *fbckg1hZN = new TF1("fbckg1hZN","gaus(0)+gaus(3)",0.,1.);
TF1 *fbckg1emZN = new TF1("fbckg1emZN","gaus(0)+gaus(3)",0.,1.);
//
///////////////////////////////////////////////////////////////////////////////
  
//----------------------------------------------------------------------------
void rdcards(){
// read data cards and fill structures accordingly
// the name of the file containg data card is fixed "fastmc.dat"
Int_t nnfix = 0;
Double_t param[6] = {0., };
Int_t par[9] = {0, };
char filename[80];
FILE *fp1 = fopen("fastmc.dat","r");
printf("\n\n Opening input file fastmc.dat to read data cards\n");

//  read one card for idgen  and ebpern
fscanf(fp1,"%d %lf %lf %lf %lf %lf", &par[0], &param[0], &param[1], &param[2], &param[3], &param[4]);
steer.idgen = par[0];
//
if(TMath::Abs(steer.idgen)==1) {
 steer.Aproj = param[0];
 steer.Zproj = param[1];
 steer.Atarg = param[2];
 steer.Ztarg = param[3];
 steer.ebpern = param[4];
 printf(" Event generator used : HIJING\n");
 printf(" process simulated: nucleus-nucleus collision\n");
 fscanf(fp1,"%s ",filename);
 printf(" file name = %s\n",filename);
 strcpy(steer.HIJ_Filename,filename);
 printf(" collision system Aproj = %f, Zproj = %f\n",steer.Aproj,steer.Zproj);
 printf(" collision system Atarg = %f, Ztarg = %f\n",steer.Atarg,steer.Ztarg);
 printf(" Energy per nucleon in lab frame = %f\n",steer.ebpern);
} 
else if (TMath::Abs(steer.idgen)==2) {
 steer.Aproj = param[0];
 steer.Zproj = param[1];
 steer.Atarg = param[2];
 steer.Ztarg = param[3];
 steer.ebpern = param[4];
 printf(" Event generator used : HIJING\n");
 printf(" process simulated: proton-proton collision\n");
 fscanf(fp1,"%s ",filename);
 printf(" file name = %s\n",filename);
 strcpy(steer.HIJ_Filename,filename);
//
} 
else if (TMath::Abs(steer.idgen)==3){ // test particles ------------------------------------
 int pdgcode = TMath::Nint(param[0]); // pdgcode
 if(steer.ebpern==0) printf(" -- Test particles tracked: nuclear fragments from AAMC\n");
 else  printf(" -- Test particles %d tracked\n", pdgcode);
 ev2.katt[0][0] = pdgcode;
 int iparticipant = 1; // NB->ai partecipanti non aggiungiamo Fermi motion!
 if(pdgcode > 1000000) {
   current.charge = param[1]; // Z
   current.Anucl = param[2]; // A
   current.ZoverA = current.charge/current.Anucl; 
   printf(" !!! Z %1.0f  A %1.0f  Z/A %1.3f", current.charge, current.Anucl, current.ZoverA);
   current.partfl = true;
   nnfix = 1;
   ev1.natt = nnfix;
 } else {
   current.ZoverA = 1;
   iparticipant = TMath::Nint(param[1]);
   if(iparticipant == 0) {
     current.partfl = false;
   } else {
     current.partfl = true;
   }
   nnfix = TMath::Nint(param[2]);
   ev1.natt = nnfix;
 }
 steer.ebpern = param[3]; // se = 0 prende 4mom dalla parametrizzazione AAMC
 steer.sigmap = param[4]; // se prec. param = 0 e' il numero del frammento da considerare
 if (pdgcode==2112 && iparticipant == 0) {
   printf("\n Spectator neutron with average momentum = %f GeV/c\n", steer.ebpern);
   //printf(" number of n per event = %d\n", nnfix);
 } else if (pdgcode==2212 && iparticipant == 0) {
   printf("\n Spectator protons with average momentum = %f GeV/c\n", steer.ebpern);
   //printf(" number of p per event = %d\n", nnfix);
 } else if(pdgcode>1000000){
   printf("  \t PDGcode = %d  \n",pdgcode);
   printf("  \t  4mom choise %1.0f [if == 0 -> takes AAMC parametrization]\n",steer.ebpern);
   printf(" particle is a fragment with Z = %f, A = %f -> ",current.charge,current.Anucl);
   printf(" Z/A = %f\n",current.ZoverA);
   if(steer.ebpern == 0) printf(" I will track fragment no. #%1.0f in table from AAMC\n", steer.sigmap);
 }
} else if (TMath::Abs(steer.idgen)==5){
 printf(" Single em dissociation - \n");
 printf(" from ntuples produced by Igor Psheniknov\n");
 fscanf(fp1,"%s ",filename);
 printf(" file name = %s\n",filename);
 strcpy(steer.EMD_Filename,filename);
 femd = new TFile(steer.EMD_Filename);
 h2034 = (TTree*) femd->Get("h2034");
 h2034->SetBranchAddress("N_na50",&nmul);
 h2034->SetBranchAddress("Pxna50",&npx[0]);
 h2034->SetBranchAddress("Pyna50",&npy[0]);
 h2034->SetBranchAddress("Pzna50",&npz[0]);
 h2034->SetBranchAddress("N_na50_p",&pmul);
 h2034->SetBranchAddress("Pxna50_p",&ppx[0]);
 h2034->SetBranchAddress("Pyna50_p",&ppy[0]);
 h2034->SetBranchAddress("Pzna50_p",&ppz[0]);
} 
/* else if (TMath::Abs(steer.idgen)==6) {
 printf(" Event generator used : FLUKA\n");
 printf(" process simulated: nucleus-nucleus collision\n");
 fscanf(fp1,"%s ",filename);
 printf(" file name = %s\n",filename);
 strcpy(steer.HIJ_Filename,filename);
 printf(" collision system Aproj = %f, Zproj = %f\n",steer.Aproj,steer.Zproj);
 printf(" collision system Atarg = %f, Ztarg = %f\n",steer.Atarg,steer.Ztarg);
 printf(" Energy per nucleon in lab frame = %f\n",steer.ebpern);
} 
else if (TMath::Abs(steer.idgen)==7){
 printf(" Event generator used : PYTHIA\n");
 printf(" process simulated: proton-proton collision\n");
 fscanf(fp1,"%s ",filename);
 printf(" file name = %s\n",filename);
 strcpy(steer.HIJ_Filename,filename);
 steer.ebpern=param[4];
 printf(" Energy of each proton in lab frame = %f\n",steer.ebpern);
} */

// read one card for the name of the file where the output tree will be stored
 printf(" Output tree stored in file "); 
 fscanf(fp1,"%s ",filename);
 printf(" %s\n",filename);
 strcpy(steer.OutTree_Filename,filename);
//  read one card for nevmax and nevfreq
fscanf(fp1,"%d %d %d",&par[0],&par[1],&par[2]);
steer.nevmax = par[0];
steer.nevfreq = par[1];
steer.nevfrst = par[2];
// printf(" max. number of events to be simulated = %d\n",steer.nevmax);
// printf(" debug printings every %d events\n",steer.nevfreq);
// printf(" first event to be read = %d\n",steer.nevfrst);
//read constant parameters for the layout
//  read one card for ZN1
fscanf(fp1,"%lf %lf %lf %lf %lf %lf",&param[0],&param[1],&param[2],&param[3],&param[4],&param[5]);
//printf("geom parameters for ZN1 =%f %f %f %f %f %f\n",param[0],param[1],param[2],param[3],param[4],param[5]);
geom.xczn[0] = param[0];
geom.yczn[0] = param[1];
geom.distn[0] = param[2];
geom.hxzn[0] = param[3];
geom.hyzn[0] = param[4];
geom.thickzn[0] = param[5];
 /*printf(" Side one  -  Neutron calorimeter : ZN\n");
 printf(" Center of ZN: x = %f  -   y = %f",geom.xczn[0],geom.yczn[0]);
 printf(" Distance from target of ZN  = %f\n",geom.distn[0]);
 printf(" x,y half-dimensions of the ZN calorimeter = %f %f\n",geom.hxzn[0],geom.hyzn[0]);
 printf(" Thickness in z coordinate of ZN calorimeter = %f\n",geom.thickzn[0]);*/
//  read one card for ZN2
fscanf(fp1,"%lf %lf %lf %lf %lf %lf",&param[0],&param[1],&param[2],&param[3],&param[4],&param[5]);
//printf("geom parameters for ZN2 =%f %f %f %f %f %f\n",param[0],param[1],param[2],param[3],param[4],param[5]);
geom.xczn[1] = param[0];
geom.yczn[1] = param[1];
geom.distn[1] = param[2];
geom.hxzn[1] = param[3];
geom.hyzn[1] = param[4];
geom.thickzn[1] = param[5];
 /*printf(" Side two  -  Neutron calorimeter : ZN\n");
 printf(" Center of ZN: x = %f  -   y = %f",geom.xczn[1],geom.yczn[1]);
 printf(" Distance from target of ZN  = %f\n",geom.distn[1]);
 printf(" x,y half-dimensions of the ZN calorimeter = %f %f\n",geom.hxzn[1],geom.hyzn[1]);
 printf(" Thickness in z coordinate of ZN calorimeter = %f\n",geom.thickzn[1]);*/
//  read one card for ZP1
fscanf(fp1,"%lf %lf %lf %lf %lf %lf",&param[0],&param[1],&param[2],&param[3],&param[4],&param[5]);
//printf("geom parameters for ZP1 =%f %f %f %f %f %f\n",param[0],param[1],param[2],param[3],param[4],param[5]);
geom.xczp[0] = param[0];
geom.yczp[0] = param[1];
geom.distp[0] = param[2];
geom.hxzp[0] = param[3];
geom.hyzp[0] = param[4];
geom.thickzp[0] = param[5];
 /*printf(" Side one  -  Proton calorimeter : ZP\n");
 printf(" Center of ZP: x = %f  -   y = %f",geom.xczp[0],geom.yczp[0]);
 printf(" Distance from target of ZP  = %f\n",geom.distp[0]);
 printf(" x,y half-dimensions of the ZP calorimeter = %f %f\n",geom.hxzp[0],geom.hyzp[0]);
 printf(" Thickness in z coordinate of ZP calorimeter = %f\n",geom.thickzp[0]);*/
//  read one card for ZP2
fscanf(fp1,"%lf %lf %lf %lf %lf %lf",&param[0],&param[1],&param[2],&param[3],&param[4],&param[5]);
//printf("geom parameters for ZP2 =%f %f %f %f %f %f\n",param[0],param[1],param[2],param[3],param[4],param[5]);
geom.xczp[1] = param[0];
geom.yczp[1] = param[1];
geom.distp[1] = param[2];
geom.hxzp[1] = param[3];
geom.hyzp[1] = param[4];
geom.thickzp[1] = param[5];
 /*printf(" Side two  -  Proton calorimeter : ZP\n");
 printf(" Center of ZP: x = %f  -   y = %f",geom.xczp[1],geom.yczp[1]);
 printf(" Distance from target to ZP  = %f\n",geom.distp[1]);
 printf(" x,y half-dimensions of the ZP calorimeter = %f %f\n",geom.hxzp[1],geom.hyzp[1]);
 printf(" Thickness in z coordinate of ZP calorimeter = %f\n",geom.thickzp[1]);*/
//  read one card for ZEM1
fscanf(fp1,"%lf %lf %lf %lf %lf %lf",&param[0],&param[1],&param[2],&param[3],&param[4],&param[5]);
//printf("geom parameters for ZEM1 =%f %f %f %f %f %f\n",param[0],param[1],param[2],param[3],param[4],param[5]);
geom.xczem[0] = param[0];
geom.yczem[0] = param[1];
geom.distem[0] = param[2];
geom.hxzem[0] = param[3];
geom.hyzem[0] = param[4];
geom.thickzem[0] = param[5];
 /*printf(" Electromagnetic calorimeters only on one side\n");
 printf(" simmetrically located w.r.t. LHC axis\n");
 printf(" Center of first ZEM: x = %f   -   y = %f\n",geom.xczem[0],geom.yczem[0]);
 printf(" Distance from target to first ZEM = %f\n",geom.distem[0]);
 printf(" x,y half-dimensions of first ZEM calorimeter: %f %f\n",geom.hxzem[0],geom.hyzem[0]);
 printf(" Thickness of first ZEM calorimeter = %f\n",geom.thickzem[0]);*/
//  read one card for ZEM2
fscanf(fp1,"%lf %lf %lf %lf %lf %lf",&param[0],&param[1],&param[2],&param[3],&param[4],&param[5]);
//printf("geom parameters for ZEM2 =%f %f %f %f %f %f\n",param[0],param[1],param[2],param[3],param[4],param[5]);
geom.xczem[1] = param[0];
geom.yczem[1] = param[1];
geom.distem[1] = param[2];
geom.hxzem[1] = param[3];
geom.hyzem[1] = param[4];
geom.thickzem[1] = param[5];
 /*printf(" Center of second ZEM: x = %f   -   y = %f\n",geom.xczem[1],geom.yczem[1]);
 printf(" Distance from target to second ZEM = %f\n",geom.distem[1]);
 printf(" x,y half-dimensions of second ZEM calorimeter: %f %f\n",geom.hxzem[1],geom.hyzem[1]);
 printf(" Thickness of second ZEM calorimeter = %f\n",geom.thickzem[1]);*/
//read one card containing steering flags
//flags: divergence,intersection volume,crossing angle,Fermi,fragm.,enres,backgrnd in ZP,newrdout
fscanf(fp1,"%d %d %d %d %d %d %d %d %d",&par[0],&par[1],&par[2],&par[3],&par[4],&par[5],&par[6],&par[7],&par[8]);
printf(" Steering flags = %d %d %d %d %d %d %d %d %d\n",par[0],par[1],par[2],par[3],par[4],par[5],par[6],par[7],par[8]);
steer.ifl_div = par[0];
steer.ifl_ip = par[1];
steer.ifl_cros = par[2];
steer.ifl_fermi = par[3];
steer.ifl_frag = par[4];
steer.ifl_res = par[5];
steer.ifl_bckgrnd = par[6];
steer.ifl_nf = par[7];
steer.ifl_newrdout = par[8];
//read beam divergence angle, if required
if(steer.ifl_div != 0) {
 fscanf(fp1,"%lf",&param[0]);
 inibeam.theta_div = param[0];
 printf(" Beam divergency taken into account ev. by ev. - theta_div = %f\n",inibeam.theta_div);}
else {
  printf(" No beam divergency\n");
}
if(steer.ifl_ip!=0) {
 fscanf(fp1,"%lf %lf %lf %lf %lf %lf %d",&param[0],&param[1],&param[2],&param[3],&param[4],&param[5],&par[0]);
 inibeam.ibeamfl = par[0];
 inibeam.xbeam = param[0];
 inibeam.dxbeam = param[1];
 inibeam.ybeam = param[2];
 inibeam.dybeam = param[3];
 inibeam.zbeam = param[4];
 inibeam.dzbeam = param[5];
 printf(" Beam positions at IP: x = %f, y = %f, z= %f\n",inibeam.xbeam,inibeam.ybeam,inibeam.zbeam);
 printf(" Beam dimensions at IP: dx = %f, dy = %f, dz= %f\n",inibeam.dxbeam,inibeam.dybeam,inibeam.dzbeam);
 if(inibeam.ibeamfl==0) printf(" gaussian beam smearing\n");
 if(inibeam.ibeamfl==1) printf(" flat beam smearing\n");
 }
else {
 printf(" No beam dimensions at the IP\n");
}
if(steer.ifl_cros!=0) {
 fscanf(fp1,"%lf",&param[0]);
 inibeam.BeamCrossAngle = param[0];
 printf(" Half crossing angle = %f\n",inibeam.BeamCrossAngle);
 printf(" ONLY Crossing angle in vertical plane is considered\n");
}
else {
  printf(" No crossing angle!\n");
}
if(steer.ifl_fermi!=0) {
 printf(" Fermi motion taken into account\n");
 printf(" Model used: two gaussian from Ilijnov\n");
}
else {
  printf(" No Fermi motion inserted for spectator nucleons!\n");
}
if(steer.ifl_frag!=0) {
 if(steer.ifl_frag == 1){
   printf(" Fragmentation will be considered\n");
   printf(" free neutrons and protons from a parametrization of results by SMM model\n");
   printf(" see for details : /home/gallio/smm/note_smm_2.txt\n");
   printf(" and eyyubova2.f and cfr_dati_sim.C in /home/gallio/opt2011\n");
 }
 if(steer.ifl_frag == 2){
   printf(" Fragmentation will be considered\n");
   printf(" free neutrons and protons from a data driven parameterization\n");
   printf(" for more details see: /home/mauro/fmc/progs/ddfrag.C\n");
 }
 if(steer.ifl_frag == 3){
   printf(" Fragmentation will be considered\n");
   printf(" free neutrons and protons from a simple model (emulsion experiments)\n");
   printf(" same number of free neutrons and free protons\n");
 }
 if(steer.ifl_frag == 4){
   printf(" Fragmentation will be considered\n");
   printf(" free neutrons and protons from a simple model (emulsion experiments)\n");
   printf(" + some parametrization from Dubna experiment\n");
 }
}
else {
  printf(" No fragmentation after interaction\n");
}
if(steer.ifl_res==2) {
 fscanf(fp1,"%lf %lf %lf %lf",&param[0],&param[1],&param[2],&param[3]);
 steer.ZNhadSigmaRes[0] = param[0];
 steer.ZNhadSigmaRes[1] = param[1];
 steer.ZNemSigmaRes[0] = param[2];
 steer.ZNemSigmaRes[1] = param[3];
 fscanf(fp1,"%lf %lf %lf %lf",&param[0],&param[1],&param[2],&param[3]);
 steer.ZPhadSigmaRes[0] = param[0];
 steer.ZPhadSigmaRes[1] = param[1];
 steer.ZPemSigmaRes[0] = param[2];
 steer.ZPemSigmaRes[1] = param[3];
 printf(" Exp. resolution of calos taken into account\n");
 printf(" sigmaE/E params for hadronic showers in ZN  = %f %f\n",steer.ZNhadSigmaRes[0],steer.ZNhadSigmaRes[1]);
 printf(" sigmaE/E params for em showers in ZN  = %f %f\n",steer.ZNemSigmaRes[0],steer.ZNemSigmaRes[1]);
 printf(" sigmaE/E params for hadronic showers in ZP  = %f %f\n",steer.ZPhadSigmaRes[0],steer.ZPhadSigmaRes[1]);
 printf(" sigmaE/E params for em showers in ZP  = %f %f\n",steer.ZPemSigmaRes[0],steer.ZPemSigmaRes[1]);}
else if(steer.ifl_res==1) {
 steer.ZNhadSigmaRes[0]=2.566;
 steer.ZNhadSigmaRes[1]=0.103;
 steer.ZNemSigmaRes[0]=0.90;
 steer.ZNemSigmaRes[1]=0.0;
 steer.ZPhadSigmaRes[0]=2.37;
 steer.ZPhadSigmaRes[1]=0.125;
 steer.ZPemSigmaRes[0]=1.07;
 steer.ZPemSigmaRes[1]=0.05;
 printf(" \n Exp. resolution of calos taken into account\n");
 printf(" sigmaE/E params for hadronic showers in ZN  = %f %f\n",steer.ZNhadSigmaRes[0],steer.ZNhadSigmaRes[1]);
 printf(" sigmaE/E params for em showers in ZN  = %f %f\n",steer.ZNemSigmaRes[0],steer.ZNemSigmaRes[1]);
 printf(" sigmaE/E params for hadronic showers in ZP  = %f %f\n",steer.ZPhadSigmaRes[0],steer.ZPhadSigmaRes[1]);
 printf(" sigmaE/E params for em showers in ZP  = %f %f\n\n",steer.ZPemSigmaRes[0],steer.ZPemSigmaRes[1]);}
else {
 printf(" Experimental resolution of calos NOT considered\n");
}
if(steer.ifl_bckgrnd==1 || steer.ifl_bckgrnd==3) {
  printf(" the background induced in both hadronic calos\n");
  printf(" by the beam pipe is considered:\n");
  printf(" the energy and the spectrum shape is inferred by GEANT3 simulations\n");
  printf(" of spectator particles of energies from 0. to 5 TeV\n");}
else if(steer.ifl_bckgrnd==2 || steer.ifl_bckgrnd==3) {
  printf(" the background induced by the surrounding material in ZN and ZP\n");
  printf(" is considered; photoelectrons produced in the naked fibers is included\n");
  printf(" as explained in file logbook_aprile2020.txt\n");}
else {
  printf(" no background is considered\n");
}
if(steer.ifl_nf!=0) {
  printf(" the photoelectrons in the naked fibres are evaluated\n"); 
  printf(" by means of a parametrization from full GEANT3 fortran simulation\n");
  printf(" the cross talk of signals in one hadron calorimeter due to showers\n");
  printf(" in the other is also evaluated\n");
}
if(steer.ifl_newrdout!=0) {
  printf(" new data format for the continuous readout in the tree\n");
  printf(" for the moment a collection of 24 ADC sampling values for each PM is written\n");
  printf(" FMC ioxos used: digitizer frequency = 480 MHz, decimation enabled\n");
  if(TMath::Abs(steer.ifl_newrdout) == 1) {
    fscanf(fp1,"%lf",&param[0]);
    steer.SigmaTOF=param[0];
    printf(" sigma of time distribution = %f ns\n",steer.SigmaTOF);
    printf(" no base line spread insertion\n");}
  else if(TMath::Abs(steer.ifl_newrdout) == 2) {
    fscanf(fp1,"%lf %lf %lf",&param[0],&param[1],&param[2]);
    steer.SigmaTOF=param[0];
    steer.BaseLineMean=param[1];
    steer.BaseLineSpread=param[2];
    printf(" sigma of time distribution = %f ns\n",steer.SigmaTOF);
    printf(" Base Line Mean  = %f V\n",steer.BaseLineMean);
    printf(" Base Line Spread  = %f V\n",steer.BaseLineSpread); 
    if(steer.ifl_newrdout<0) printf(" only base line calculation has to be done\n");
  }
}
printf(" -------------------------------------------------------------\n\n");
fclose(fp1);
}

//---------------------------------------------------------------------------------------
void rdlist(){
// read file (name fixed "magline.dat") containing the parameters for
// all the magnetic elements from vertex to the ZDC location
FILE *fp2 = fopen("magline.dat","r");
par_ele.num = 0;
Int_t ncols = 0;
Int_t nlines = 0;
char str1[6];
Double_t a = 0, b = 0, c = 0, d = 0, e = 0, f = 0;
Bool_t radial_ap = kTRUE;
DriftEle *element_d[10];
QuadEle *element_q[10];
BendEle *element_b[10];

while (1)
{
   ncols = fscanf(fp2,"%s %lf %lf %lf %lf %lf %lf",&str1[0],&a,&b,&c,&d,&e,&f);
   if (ncols < 0) break;    
   //      printf("ncols = %d\n",ncols);
   strcpy(par_ele.type[nlines],str1);
   //      printf("type = %s\n",str1); 
      
  if(strcmp(str1, "drift") == 0) { 
    par_ele.par[nlines][0] = a;
    par_ele.par[nlines][1] = b;
    par_ele.par[nlines][2] = c;
    par_ele.par[nlines][3] = d;
	  printf("  - drift element: param = %f %f %f %f\n",a,b,c,d);
    nlines++;
  }
  else if (strcmp(str1, "quad") == 0){ 
     par_ele.par[nlines][0] = a;
     par_ele.par[nlines][1] = b;
     par_ele.par[nlines][2] = c;
     par_ele.par[nlines][3] = d;
     par_ele.par[nlines][4] = e;
     par_ele.par[nlines][5] = f;
	   printf("  - drift element: param = %f %f %f %f %f %f\n",a,b,c,d,e,f);
     nlines++;
   }
   else if (strcmp(str1, "bend") == 0){ 
     par_ele.par[nlines][0] = a;
     par_ele.par[nlines][1] = b;
     par_ele.par[nlines][2] = c;
     par_ele.par[nlines][3] = d;
     par_ele.par[nlines][4] = e;
     par_ele.par[nlines][5] = f;
	   printf("  - drift element: param = %f %f %f %f %f %f\n",a,b,c,d,e,f);
     nlines++;
    }
    //printf("nlines read = %d\n\n",nlines);
    par_ele.num = nlines;
}
fclose(fp2);

  maglist.fNoElements = 0;
  maglist.fElements = new TObjArray(100);
  Int_t no_d = 0;
  Int_t no_q = 0;
  Int_t no_b = 0;
  for(Int_t i = 0; i < par_ele.num; i++) {
   strcpy(str1,par_ele.type[i]);
   //printf("element no. %d - type = %s\n",i,str1);
   if(strcmp(str1, "drift") == 0) {
     //printf("params = %f %f %f %f\n",par_ele.par[i][0], par_ele.par[i][1],par_ele.par[i][2], par_ele.par[i][3]);
     element_d[no_d] = new DriftEle();
     radial_ap = kTRUE;
     if(par_ele.par[i][2] != 0) radial_ap = kFALSE;
     element_d[no_d]->SetParEle(par_ele.par[i][0], par_ele.par[i][1], radial_ap, par_ele.par[i][3]);
     //     element_d[no_d]->PrintStatus();
     Double_t len = element_d[no_d]->GetLength();
     Double_t z = element_d[no_d]->GetZPos();
     Bool_t ap_type = element_d[no_d]->GetApertType();
     Double_t aperture = element_d[no_d]->GetAperture1();
     /*printf("length = %f  -  z position = %f\n",len,z);
     if(ap_type) { 
      printf("radial aperture\n");
     } else { 
      printf("vertical aperture\n");
     }
     printf("aperture = %f\n",aperture);*/
     maglist.fElements->Add(element_d[no_d]);
     //     maglist.fElements->Dump();
     no_d++;
   }
   if(strcmp(str1, "quad") == 0) {
     //printf("params = %f %f %f %f %f %f\n",par_ele.par[i][0], par_ele.par[i][1],par_ele.par[i][2], par_ele.par[i][3],par_ele.par[i][4], par_ele.par[i][5]);
     element_q[no_q] = new QuadEle();
     radial_ap = kTRUE;
     if(par_ele.par[i][4] != 0) radial_ap = kFALSE;
     element_q[no_q]->SetParEle(par_ele.par[i][0], par_ele.par[i][1],par_ele.par[i][2], par_ele.par[i][3], radial_ap, par_ele.par[i][5]);
     Double_t len = element_q[no_q]->GetLength();
     Double_t z = element_q[no_q]->GetZPos();
     Bool_t ap_type = element_q[no_q]->GetApertType();
     Double_t aperture = element_q[no_q]->GetAperture1();
     /*printf("length = %f  -  z position = %f\n",len,z);
     if(ap_type) { 
      printf("radial aperture\n");
     } else { 
      printf("rectangular aperture\n");
     }
     printf("aperture = %f\n",aperture);*/
     maglist.fElements->Add(element_q[no_q]);
     no_q++;
   }
   if(strcmp(str1, "bend") == 0) {
     //printf("params = %f %f %f %f  %f %f\n",par_ele.par[i][0], par_ele.par[i][1],par_ele.par[i][2], par_ele.par[i][3],par_ele.par[i][4], par_ele.par[i][5]);
     element_b[no_b] = new BendEle();
     radial_ap = kTRUE;
     if(par_ele.par[i][4]!=0) radial_ap = kFALSE;
     element_b[no_b]->SetParEle(par_ele.par[i][0], par_ele.par[i][1],par_ele.par[i][2], par_ele.par[i][3], radial_ap, par_ele.par[i][5]);
     Double_t len = element_b[no_b]->GetLength();
     Double_t z = element_b[no_b]->GetZPos();
     Bool_t ap_type = element_b[no_b]->GetApertType();
     Double_t aperture = element_b[no_b]->GetAperture1();
     if(ap_type) { 
      //printf("radial aperture\n");
     } else { 
      //printf("rectangular aperture\n");
     }
     //printf("aperture = %f\n",aperture);
     //printf("length = %f  -  z position = %f\n",len,z);
     maglist.fElements->Add(element_b[no_b]);
     no_b++;
   }
  maglist.fNoElements++;
  }
  printf("  +] no. of drift elements = %d\n",no_d);
  printf("  +] no. of quad elements = %d\n",no_q);
  printf("  +] no. of bend elements = %d\n\n",no_b);
}

//----------------------------------------------------------------------------------
void rmv_fr(Int_t ipspec, Int_t inspec, Int_t &npf, Int_t &nnf){
//    Double_t bmax_cs=17.5;
    Double_t avfn=0.;
    Double_t avfp=0.;
    static Double_t c_pb_n[4] = {2.6453, -1.4627,  0.92266, -0.46428E-01};
    static Double_t c_pb_p[4] = {0.55181, 0.17406, 0.19849, -0.12357E-01};
    static Double_t c_xe_n[4] = {2.786,  -1.4557,  0.70712, -0.38864e-01};
    static Double_t c_xe_p[4] = {0.6342,  0.16623, 0.15300, -0.10876e-01};
    static Double_t c_ox_n[6] = {1.439,0.361,-0.581,0.253,-0.0354,0.001535};
    static Double_t c_ox_p[6] = {1.439,0.361,-0.581,0.253,-0.0354,0.001535};
    static Double_t errpc = 0.15;
    
/*
    printf("inside rmv_fr: b = %f\n",ev1.b);
    printf("inside rmv_fr: inspec = %d   -  ipspec = %d\n",inspec,ipspec);
    printf("Aproj = %f , Zproj = %f\n",steer.Aproj,steer.Zproj);
*/
    if(inspec>0) {
      if(steer.Aproj==208.){
        avfn=c_pb_n[0]+c_pb_n[1]*ev1.b+c_pb_n[2]*ev1.b*ev1.b+c_pb_n[3]*ev1.b*ev1.b*ev1.b;
      } else if(steer.Aproj==129.){
        avfn=c_xe_n[0]+c_xe_n[1]*ev1.b+c_xe_n[2]*ev1.b*ev1.b+c_xe_n[3]*ev1.b*ev1.b*ev1.b;
      } else if(steer.Aproj==16.){
        avfn=c_ox_n[0]+c_ox_n[1]*ev1.b+c_ox_n[2]*ev1.b*ev1.b+c_ox_n[3]*ev1.b*ev1.b*ev1.b+c_ox_n[4]*ev1.b*ev1.b*ev1.b*ev1.b+c_ox_n[5]*ev1.b*ev1.b*ev1.b*ev1.b*ev1.b;
      }
      Double_t dfn=errpc*avfn;
      Double_t fn=gRandom->Gaus(avfn,dfn);
//      printf("avfn = %f - dfn = %f - fn =%f\n",avfn,dfn,fn);
      if(fn<0.0) fn=0.0;
      nnf=TMath::Nint(fn);
      if(nnf>inspec) nnf=inspec;
//      printf("nnf =%d\n",nnf);
    }
    else {
      nnf=0;
//      printf("nnf =%d\n",nnf);
    }
    if(ipspec>0) {
      if(steer.Aproj==208.){
        avfp=c_pb_p[0]+c_pb_p[1]*ev1.b+c_pb_p[2]*ev1.b*ev1.b+c_pb_p[3]*ev1.b*ev1.b*ev1.b;
      } else if(steer.Aproj==129.){
        avfp=c_xe_p[0]+c_xe_p[1]*ev1.b+c_xe_p[2]*ev1.b*ev1.b+c_xe_p[3]*ev1.b*ev1.b*ev1.b;
      } else if(steer.Aproj==16.){
        avfp=c_ox_p[0]+c_ox_p[1]*ev1.b+c_ox_p[2]*ev1.b*ev1.b+c_ox_p[3]*ev1.b*ev1.b*ev1.b+c_ox_p[4]*ev1.b*ev1.b*ev1.b*ev1.b+c_ox_p[5]*ev1.b*ev1.b*ev1.b*ev1.b*ev1.b;
      }
      Double_t dfp=errpc*avfp;
      Double_t fp=gRandom->Gaus(avfp,dfp);
//      printf("avfp = %f - dfp = %f - fp =%f\n",avfp,dfp,fp);
      if(fp<0.0) fp=0.0;
      npf=TMath::Nint(fp);
      if(npf>ipspec) npf=ipspec;
//      printf("npf =%d\n",npf);
    }
    else {
      npf=0;
//      printf("npf =%d\n",npf);
    }
}

//---------------------------------------------------------------------------------------
Double_t frn(Double_t xx)
{
   const Double_t par_frn[5] = {0.9344, -0.1824, 0.02625, -0.001654, 3.233e-5};
   Double_t val = par_frn[0]+par_frn[1]*xx+par_frn[2]*xx*xx+par_frn[3]*xx*xx*xx+par_frn[4]*xx*xx*xx*xx;
   if(val<0.) val = 0.0;
   return val;
}
Double_t frp(Double_t xx)
{
   const Double_t par_frp[7] = {0.4314, -0.0622, 0.01126, -0.00104, 3.001e-5, 0.3561, -0.021};
   Double_t junction = 15.; 
   Double_t val;
   if(xx<junction) {
     val = par_frp[0]+par_frp[1]*xx+par_frp[2]*xx*xx+par_frp[3]*xx*xx*xx+par_frp[4]*xx*xx*xx*xx;
   } else {
     val = par_frp[5]+par_frp[6]*xx;
   }
   if(val<0.) val = 0.0;
   return val;
}

//---------------------------------------------------------------------------------------
void rmv_fr2(Int_t ipspec, Int_t inspec, Int_t &npf, Int_t &nnf){

// the function comes from Pb-Pb collisions data
// to be used with other simmetric collisions ons has to rescale 
// the impact parameter with ratio where
// ratio is the ratio between the radius of Pb over the ratio of 
// the considered colliding nuclei
const Double_t ratio = 2.35;  //from PbPb to OO

   Double_t bimpact = ev1.b;
   if(steer.Aproj == 16.) {
     bimpact = ev1.b * ratio;
   }
   Double_t corrp =  frp(bimpact);
   npf = Int_t(ipspec*corrp+0.5);
   Double_t corrn =  frn(bimpact);
   nnf = Int_t(inspec*corrn+0.5);

   if(current.evnt%steer.nevfreq==0) {
     //printf(" impact parameter = %f\n",bimpact);
     //printf(" corrn = %f,  corrp = %f\n",corrn,corrp);
     //printf(" nnf = %d,  npf = %d\n",nnf,npf);
   }
}

//---------------------------------------------------------------------------------------
void rmv_fr3(Int_t ipspec, Int_t inspec, Int_t &npf, Int_t &nnf){
Double_t Zbound;
Double_t avfp,avfn;
const Double_t bch = 0.5;
const Double_t errpc = 0.15;
const Double_t Q[24] = {0.00,0.0427,0.171,0.384,0.683,1.067,
 1.535,2.087,2.720,3.430,4.206,5.028,
 5.860,6.646,7.319,7.832,8.179,8.393,
 8.516,8.584,8.621,8.640,8.651,8.656};

//  from b to centrality. Distribution of b parametrized with
//  the function  TF1("f","[0]*x/(1.+exp((x-[1])/[2]))",0.,bmax)
//  the three parameters from fit to 100000 HIJING events are:
//  [0] = normalization = 427.;
//  [1] = bmax (for O-O bmax = 7 fm)
//  [2] = skin of nuclei = deltab = 0.722 fm

    if(current.evnt%steer.nevfreq==0) {
      //printf("inside rmv_fr: b = %f\n",ev1.b);
      //printf("inside rmv_fr: inspec = %d   -  ipspec = %d\n",inspec,ipspec);
    }
    if(ipspec>0) {
      Double_t bimp = 0.;
      int ii=0;
      for(int i=0; i<24; i++) {
        bimp += bch;
	ii=i;
	if(bimp>ev1.b) break; 
      }
      int i1 = ii;
      int i2 = ii+1;
      Double_t b1 = bch*i1;
      Double_t b2 = b1+bch;
//      printf("i1 = %d - i2 = %d\n",i1,i2);
//      printf("b1 = %f - b2 = %f\n",b1,b2);
      Double_t delta = (Q[2]-Q[1])/(b2-b1);
      Zbound = Q[i1]+delta*(ev1.b-b1);
      avfp = ipspec*1. - Zbound;
      Double_t dfp=errpc*avfp;
      Double_t fp=gRandom->Gaus(avfp,dfp);
      if(fp<0.0) fp=0.0;
      if(current.evnt%steer.nevfreq==0) {
        //printf(" Q1 = %f , Q2 = %f , Zbound = %f\n",Q[i1],Q[i2],Zbound);
        //printf("avfp = %f - dfp = %f - fp =%f\n",avfp,dfp,fp);
      }
      npf=TMath::Nint(fp);
      if(npf>ipspec) npf=ipspec;
    }
    else {
      npf=0;
    }
    //if(current.evnt%steer.nevfreq==0) printf("npf =%d\n",npf);

    if(ipspec>0) {
      avfn = avfp;
      Double_t dfn=errpc*avfn;
      Double_t fn=gRandom->Gaus(avfn,dfn);
      //if(current.evnt%steer.nevfreq==0) printf("avfn = %f - dfn = %f - fn =%f\n",avfn,dfn,fn);
      if(fn<0.0) fn=0.0;
      nnf=TMath::Nint(fn);
      if(nnf>inspec) nnf=inspec;
    }
    else {
      nnf=0;
   }
   //if(current.evnt%steer.nevfreq==0) printf("nnf =%d\n",nnf);
}

// ---------------------------------------------------------------
void rmv_fr4(Int_t ipspec, Int_t inspec, Int_t &npf, Int_t &nnf){
  Double_t Zbound = 0.;
  Int_t pbound = 0;
  Double_t avfp = 0.,avfn = 0.;
  Double_t bch = 0.5;
  Double_t errpc = 0.10;
  const Double_t Q[24] = {0.00,0.0427,0.171,0.384,0.683,1.067,
  1.535,2.087,2.720,3.430,4.206,5.028,
  5.860,6.646,7.319,7.832,8.179,8.393,
  8.516,8.584,8.621,8.640,8.651,8.656};
  const Double_t prob_nfr_Z1[3] = {0.338, 0.202, 0.460};
  const Double_t prob_nfr_Z2[3] = {0.654, 0.308, 0.038};

  //  from b to centrality. Distribution of b parametrized with
  //  the function  TF1("f","[0]*x/(1.+exp((x-[1])/[2]))",0.,bmax)
  //  the three parameters from fit to 100000 HIJING events are:
  //  [0] = normalization = 427.;
  //  [1] = bmax (for O-O bmax = 7 fm)
  //  [2] = skin of nuclei = deltab = 0.722 fm

  if(current.evnt%steer.nevfreq==0) {
    printf("inside rmv_fr: b = %f\n",ev1.b);
    printf("inside rmv_fr: inspec = %d   -  ipspec = %d\n",inspec,ipspec);
  }
    if(ipspec>0) {
      Double_t bimp = 0.;
      int ii=0;
      for(int i=0; i<24; i++) {
        bimp += bch;
	ii=i;
	if(bimp>ev1.b) break; 
      }
      int i1 = ii;
      int i2 = ii+1;
      Double_t b1 = bch*i1;
      Double_t b2 = b1+bch;
  //      printf("i1 = %d - i2 = %d\n",i1,i2);
  //      printf("b1 = %f - b2 = %f\n",b1,b2);
      Double_t delta = (Q[2]-Q[1])/(b2-b1);
      Zbound = Q[i1]+delta*(ev1.b-b1);
      pbound = TMath::Nint(Zbound);
      avfp = ipspec*1. - Zbound;
      Double_t dfp=errpc*avfp;
      Double_t fp=gRandom->Gaus(avfp,dfp);
      if(fp<0.0) fp=0.0;
      if(current.evnt%steer.nevfreq==0) {
        //printf(" Q1 = %f , Q2 = %f , Zbound = %f\n",Q[i1],Q[i2],Zbound);
        //printf("avfp = %f - dfp = %f - fp =%f\n",avfp,dfp,fp);
      }
      npf=TMath::Nint(fp);
      if(npf>ipspec) npf=ipspec;
    }
    else {
      npf=0;
    }
    //if(current.evnt%steer.nevfreq==0) printf("npf =%d\n",npf);

    if(inspec>0) {
    Double_t p = gRandom->Uniform(0.,1.);
    Double_t pint = 0.0;
    Int_t jn = 0;
  //    if(ideb) {
  //      printf(" probability = %f\n",p);
  //      printf(" pbound = %d\n",pbound);
  //    }
    if(pbound == 0) {
      avfn=inspec;
    } else if(pbound == 1) {
      for(int i=0; i<3; i++){
        jn = i;
        pint += prob_nfr_Z1[i];
	if(p < pint) break;
      }
      avfn = inspec -jn;
  //     if(ideb) {
  //	printf(" jn = %d - prob_nfr_Z1 = %f - pint = %f\n",jn,prob_nfr_Z1[jn],pint);
  //      printf(" avfn = %f\n",avfn);
  //      }
    } else if(pbound == 2){
      for(int i=0; i<3; i++){
        jn = i;
        pint += prob_nfr_Z2[i];
	if(p < pint) break;
      }
      if(jn == 0) {
        avfn = inspec - 1;
      } else {
        avfn = inspec -jn*2;
      }
  //      if(ideb) {
  //  	printf(" jn = %d - prob_nfr_Z2 = %f - pint = %f\n",jn,prob_nfr_Z2[jn],pint);
  //        printf(" avfn = %f\n",avfn);
  //      }
   } else {
      avfn = avfp;
   }
  //   if(ideb) printf("p = %f - integral probability = %f - jn = %d - avfn = %f\n",p,pint,jn,avfn);
     Double_t dfn=errpc*avfn;
     Double_t fn=gRandom->Gaus(avfn,dfn);
  //     if(ideb) printf("avfn = %f - dfn = %f - fn =%f\n",avfn,dfn,fn);
     if(fn<0.0) fn=0.0;
     nnf=TMath::Nint(fn);
     if(nnf>inspec) nnf=inspec;
     if(nnf<0) nnf=0;
   } else {
     nnf = 0;
   }
   //if(current.evnt%steer.nevfreq==0) printf("nnf =%d\n",nnf);
}

//---------------------------------------------------------------------------------------
Int_t ReadPYTEvnt() {
    // read one event from PYTHIA fortran unformatted output
    // the generated particles are read from files (originally written
    // by fortran programs in unformatted mode) 

    Int_t *pointer_h1;
    Int_t *pointer_h2;
    Float_t *point_h2;
    Int_t lenrec_byte;
    Int_t nword;
    Int_t nwords_rec, npart;
    Int_t ids[2];
    Float_t pmom[4];

    //
    //  read one PYTHIA event from file fev and fill two structures 
    //  (equivalent of the fortran common blocks)
    //
    nword = fread(&lenrec_byte, sizeof(Int_t), 1, fev); //first word of the record
	  nwords_rec=lenrec_byte/4;
    pointer_h1=&ev1.natt;
	  nword=fread(pointer_h1,sizeof(Int_t), 1, fev);
    //	if(current.evnt%steer.nevfreq==0) printf("mulPyt = %d\n",ev1.natt);
	  for(Int_t i=0; i<ev1.natt; i++){
      //	  printf("-- particella no. %d\n",i);
	    pointer_h2=&ids[0];
	    nword=fread(pointer_h2, sizeof(Int_t),2,fev);
	    ev2.katt[0][i] = ids[0];
	    ev2.katt[1][i] = ids[1];
      //	  printf("numero parole lette = %d\n",nword);
      //	  printf("kid = %d %d\n",ev2.katt[0][i],ev2.katt[1][i]);
	    point_h2=&pmom[0];
	    nword=fread(point_h2, sizeof(Float_t),4,fev);
	    ev2.patt[0][i] = pmom[0];
	    ev2.patt[1][i] = pmom[1];
	    ev2.patt[2][i] = pmom[2];
	    ev2.patt[3][i] = pmom[3];
      //	  printf("numero parole lette = %d\n",nword);
      //	  printf("pmom = %f %f %f %f\n",ev2.patt[0][i],ev2.patt[1][i],ev2.patt[2][i],ev2.patt[3][i]);
	  }
    nword = fread(&lenrec_byte, sizeof(Int_t), 1, fev); //last word of the record
	  return 0;
}

//---------------------------------------------------------------------------------------
Int_t ReadHIJEvnt() {
// read one event from HIJING fortran unformatted output
// the generated particles are read from files (originally written
// by fortran programs in unformatted mode) 

    Int_t *pointer_h1;
    Int_t *pointer_h2;
    Float_t *point_h2;
    Int_t lenrec_byte;
    Int_t nword;
    Int_t nwords_rec, npart;    
    Int_t ids[2];
    Float_t pmom[4];


//
//  read one HIJING event from file fev and fill two structures 
//  (equivalent of the fortran common blocks)
//
	nword=fread(&lenrec_byte, sizeof(Int_t), 1, fev); //first word of the record
	nwords_rec=lenrec_byte/4;
        pointer_h1=&ev1.nmul;
        nword=fread(pointer_h1, sizeof(Int_t), nwords_rec, fev);
        nword=fread(&lenrec_byte, sizeof(Int_t), 1, fev); //last word of the record

        nword=fread(&lenrec_byte, sizeof(Int_t), 1, fev); //first word of the record
	nwords_rec=lenrec_byte/4;
	npart=nwords_rec/6;
	for(Int_t i=0;i<ev1.natt;i++){
	  pointer_h2=&ids[0];
	  nword=fread(pointer_h2, sizeof(Int_t),2,fev);
	  ev2.katt[0][i]=ids[0];
	  ev2.katt[1][i]=ids[1];
	  point_h2=&pmom[0];
	  nword=fread(point_h2, sizeof(Float_t),4,fev);
	  ev2.patt[0][i]=pmom[0];
	  ev2.patt[1][i]=pmom[1];
	  ev2.patt[2][i]=pmom[2];
	  ev2.patt[3][i]=pmom[3];
//	    if(i%100) continue; 
//	    printf("-- particle no. %d, ids %d %d\n",i,ev2.katt[0][i],ev2.katt[1][i]);
//	    printf("4mom %f %f %f %f\n",ev2.patt[0][i],ev2.patt[1][i],ev2.patt[2][i],ev2.patt[3][i]);
	}
        nword=fread(&lenrec_byte, sizeof(Int_t), 1, fev); //last word of the record


        Int_t nucspproj = TMath::Nint(steer.Aproj)-ev1.np; 
        Int_t nucsptarg = TMath::Nint(steer.Atarg)-ev1.nt; 
	if(current.evnt%steer.nevfreq==0) {
	  printf("*****  Event no. %d\n",current.evnt);
	  printf("HIJING event\n");
          printf("nt = %d    -    np = %d\n", ev1.nt,ev1.np);
          printf("number of spectator nucleons in projectile = %d\n",nucspproj);
          printf("number of spectator nucleons in target = %d\n",nucsptarg);
          printf("n0, n01, n10, n11 = %d %d %d %d\n", ev1.n0,ev1.n01,ev1.n10,ev1.n11);
          printf("impact parameter = %f\n", ev1.b);
          printf("reaction plane angle = %f\n", ev1.psirp); 
          printf("natt = %d\n", ev1.natt);
	  }
	return 0;
}

//------------------------------------------------------------------------------
void readev() 
{
  // read one event from generator. 
  // for the moment ONLY fortran versions of generators is allowed
  // the generated particles are read from files (originally written
  // by fortran programs in unformatted files) except if idgen is 3,4,5 
  // idgen is the generator identifier
  // idgen = 1      ==> HIJING ion collisions
  // idgen = 2      ==> HIJING proton collisions
  // idgen = 3      ==> test particle injected in setup
  // idgen = 5      ==> neutrons and protons produced by RELDIS
  // idgen = 6      ==> FLUKA  collisions but only em particles stored and tracked
  // idgen = 7      ==> PYTHIA ion collisions

  int ierr = 0;
  double sign = 0;
  int kk = 0, kpdg = 0;
  static Int_t kpdgcode[64] = {2212,-2212,11,-11,12,-12,22,2112,-2112,
     -13,13,130,211,-211,321,-321,3122,-3122,
     310,3112,3222,3212,111,311,-311,0,14,
     -14,0,0,-3222,-3212,-3112,3322,-3322,3312,
     -3312,3334,-3334,0,-15,15,16,-16,411,
     -411,421,-421,431,-431,4122,4232,4112,4322,
     4312,4332,-4122,-4232,-4132,-4322,-4312,-4332,0,0
  };
  Double_t protonmass = 0.938272;
  Double_t neutronmass = 0.939565;
  Double_t mass = 0.;

  if(TMath::Abs(steer.idgen)==1 || TMath::Abs(steer.idgen)==2) { // HIJING either pp or AA
    //  read one HIJING event from file fev and fill two structures 
    //  (equivalent of the fortran common blocks)
    
    ierr = ReadHIJEvnt();
    //    printf("after reading one HIJING event: ierr = %d\n",ierr);
            
    if(TMath::Abs(steer.idgen)==1) {
      if(steer.ifl_frag>0){
        Int_t kNspec[2];
        Int_t kPspec[2];
        Int_t k_nucl[2];
        //  zero the counting of spectator protons and neutrons
        for (Int_t k=0; k<2; k++) {
          kNspec[k]=0;
          kPspec[k]=0;
          k_nucl[k]=0;
        }      
        int kside = 0;
        int j=0;
        for(int i = 0; i < ev1.natt; i++){
          kside = 0;  //kside =0 ==> beam toward positive z axis
          if(ev2.patt[2][i] < 0.0) kside = 1; // kside =1 ==> beam toward negative z axis
          //  temporary: remove  spectator nucleons from the event structure 
          //  and fill a new event array 
          if(ev2.katt[1][i]==0) {
            k_nucl[0]++;
            if(ev2.katt[0][i]==2112) kNspec[0]++;
            if(ev2.katt[0][i]==2212) kPspec[0]++;

            if(current.evnt%steer.nevfreq==0) {
              printf("-- particle no. %d %d, ids %d %d\n",i,k_nucl[0],ev2.katt[0][i],ev2.katt[1][i]);
              printf("4mom %f %f %f %f\n",ev2.patt[0][i],ev2.patt[1][i],ev2.patt[2][i],ev2.patt[3][i]);
            }
          } else if(ev2.katt[1][i]==10) {
            k_nucl[1]++;
            if(ev2.katt[0][i]==2112) kNspec[1]++;
            if(ev2.katt[0][i]==2212) kPspec[1]++;
          
            if(current.evnt%steer.nevfreq==0) {
              printf("-- particle no. %d %d, ids %d %d\n",i,k_nucl[1],ev2.katt[0][i],ev2.katt[1][i]);
              printf("4mom %f %f %f %f\n",ev2.patt[0][i],ev2.patt[1][i],ev2.patt[2][i],ev2.patt[3][i]);
            }
          } else {
            for (Int_t k=0; k<4; k++) {
              if(k<2) ev2.katt[k][j]=ev2.katt[k][i];
              ev2.patt[k][j]=ev2.patt[k][i];
            }
            if(current.evnt%steer.nevfreq==0) {
              printf("particle no. %d - sequential ptl index =%d\n",i,j);
              printf("-- particle no. %d %d, ids %d %d\n",j,k_nucl[1],ev2.katt[0][j],ev2.katt[1][j]);
              printf("4mom %f %f %f %f\n",ev2.patt[0][j],ev2.patt[1][j],ev2.patt[2][j],ev2.patt[3][j]);
            }
            j++;
          }
        }  //end loop over particles
        /*if(current.evnt%steer.nevfreq==0) {
          printf("number of participant particles = %d\n",j);
          printf("number of spectator protons in proj = %d\n",kPspec[0]);
          printf("number of spectator neutrons in proj = %d\n",kNspec[0]);
          printf("number of spectator protons in target = %d\n",kPspec[1]);
          printf("number of spectator neutrons in target = %d\n",kNspec[1]);
        }*/
        int index = j;
        if(current.evnt%steer.nevfreq==0) {
                printf("number of participant particles = %d\n",index);
        }
        Double_t sign = 1.;
        for(Int_t i=0; i<2; i++) {
          sign = 1.0;
          if(i==1) sign = -1.0;
          Int_t inspec = kNspec[i];
          Int_t ipspec = kPspec[i];
          Int_t nnf;
          Int_t npf;
          if(steer.ifl_frag == 1) rmv_fr(ipspec,inspec,npf,nnf);
          if(steer.ifl_frag == 2) rmv_fr2(ipspec,inspec,npf,nnf);
          if(steer.ifl_frag == 3) rmv_fr3(ipspec,inspec,npf,nnf);
          if(steer.ifl_frag == 4) rmv_fr4(ipspec,inspec,npf,nnf);
          gene_t.nf[i] = nnf;
          gene_t.pf[i] = npf;

          if(current.evnt%steer.nevfreq==0) {
            printf("iside = %d\n",i);
            printf("ipspec=%d, inspec=%d\n",ipspec,inspec);
            printf("npf = %d  -  nnf = %d\n",npf,nnf);
          }
          if(npf>0) {
            for(Int_t k=0; k<npf; k++){
              ev2.katt[0][index+k] = 2212;
              ev2.katt[1][index+k] = 0;
              ev2.patt[0][index+k] = 0.;
              ev2.patt[1][index+k] = 0.;
              ev2.patt[2][index+k] = steer.ebpern*sign;
              ev2.patt[3][index+k] = steer.ebpern;
            }
            index=index+npf;
          }
          if(current.evnt%steer.nevfreq==0) {
            printf("after insertion of spectator protons of side %d = %d\n",i,index);
          }
          if(nnf>0) {
            for(Int_t k=0; k<nnf; k++){
              ev2.katt[0][index+k]=2112;
              ev2.katt[1][index+k]=0;
              ev2.patt[0][index+k]=0.;
              ev2.patt[1][index+k]=0.;
              ev2.patt[2][index+k]=steer.ebpern*sign;
              ev2.patt[3][index+k]=steer.ebpern;
            }
            index=index+nnf;
          }
          if(current.evnt%steer.nevfreq==0) {
            printf("after insertion of spectator neutrons of side %d = %d\n",i,index);
          }
        }
        ev1.natt=index;
        //  printf("number of total particles after removal of fragments = %d\n",ev1.natt);
      }
      //store the generator relevant variables
      gene_t.idgene = TMath::Abs(steer.idgen);
      gene_t.nucparp = ev1.np;	  
      gene_t.nucpart = ev1.nt;
      gene_t.prod_ptl = ev1.nmul;
      gene_t.cons_ptl = ev1.natt;
      gene_t.bimp = ev1.b;
      gene_t.psi_react_plane = ev1.psirp;
      gene_t.cons_ptl = ev1.natt;
    } // idgen==1
  }
  else if(TMath::Abs(steer.idgen)==3) { // test particle --- relevant part for FRAGMENTS
    //
    //  test particle considered
    //
    ev1.b = 9999.;
    Int_t pdg = ev2.katt[0][0];
    TParticlePDG *part = db->GetParticle(pdg);
    if(pdg < 1000000) { 
      mass = part->Mass();
    } else { //ion
      //protonmass = (db->GetParticle(2212))->Mass();
      //neutronmass = (db->GetParticle(2112))->Mass();
      int nprotons = TMath::Abs(current.charge);
      double massp = nprotons*protonmass;
      double massn = (current.Anucl-nprotons)*neutronmass;
      mass = massp+massn;
    }
    if(current.evnt%steer.nevfreq==0) {
      printf(" particle PDGcode = %d \t mass = %f\n",pdg, mass);
      //printf(" number of particles per event = %d\n", ev1.natt);
      //printf(" participant flag = %d\n", current.partfl);
    }
    for (Int_t k=0; k<ev1.natt; k++) {
      ev2.katt[0][k] = pdg;
      if(current.partfl == true) {
        ev2.katt[1][k] = 3;
      } else {
        ev2.katt[1][k] = 0;
      }
      if(steer.ebpern == 0) {
        // Parameters for momentum components of ions with Z/A != 0.5 from AAMC output
        int ion = (int) steer.sigmap; // indice del frammento da considerare (0...15)
       /*double parampFragminOO[4][15] = {  // O 0% clusterized ------------------------------
        0.120, 0.126, 0.175, 0.177, 0.180, 0.183, 0.182, 0.172, 0.175, 0.154, 0.160, 0.172, 0.150, 0.148, 0.138,
        0.120, 0.126, 0.175, 0.177, 0.179, 0.182, 0.181, 0.172, 0.175, 0.154, 0.159, 0.172, 0.149, 0.148, 0.138,
        10200, 10200, 20330, 23680, 23690, 27080, 30410, 33790, 33790, 37140, 37150, 40530, 43860, 43870, 47230,
          431,   451,   622,   629,   640,   650,   650,   620,   636,   572,   584,   622,   567,   563,   534 
        };*/
        double parampFragminOO[4][15] = { // O 100% clusterized ------------------------------
          0.094, 0.102, 0.144, 0.150, 0.153, 0.156, 0.155, 0.155, 0.157, 0.146, 0.152, 0.151, 0.136, 0.139, 0.139,
          0.094, 0.102, 0.144, 0.150, 0.154, 0.156, 0.155, 0.154, 0.157, 0.146, 0.152, 0.151, 0.136, 0.139, 0.138,
          10190, 10190, 20320, 23680, 23680, 27070, 30410, 33790, 33790, 37410, 37410, 40530, 43860, 43870, 47230,
            338,   366,   516,   536,   551,   565,   566,   570,   576,   543,   562,   562,   528,   538,   539 
        };
        //
        ev2.patt[0][k] = gRandom->Gaus(0., parampFragminOO[0][ion]);
        ev2.patt[1][k] = gRandom->Gaus(0., parampFragminOO[1][ion]);
        // come specificato da mail Gallio del 11/3/2025  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // "il tracciamento richiede che il valore della quantita' di moto sia quello riferito  
        // al *singolo nucleone* del frammento e non alla somma delle quantita' di moto dei nucleoni. "
        ev2.patt[2][k] = gRandom->Gaus(parampFragminOO[2][ion], parampFragminOO[3][ion])/current.Anucl;
        double ptot = TMath::Sqrt(ev2.patt[0][k]*ev2.patt[0][k]+ev2.patt[1][k]*ev2.patt[1][k]+ev2.patt[2][k]*ev2.patt[2][k]);
        ev2.patt[3][k] = TMath::Sqrt(ptot*ptot+mass*mass);
      } else {
        ev2.patt[0][k] = gRandom->Gaus(0., 0.1);
        ev2.patt[1][k] = gRandom->Gaus(0., 0.1);
        ev2.patt[2][k] = gRandom->Gaus(steer.ebpern, steer.sigmap);
        double ptot = TMath::Sqrt(ev2.patt[0][k]*ev2.patt[0][k]+ev2.patt[1][k]*ev2.patt[1][k]+ev2.patt[2][k]*ev2.patt[2][k]);
        ev2.patt[3][k] = TMath::Sqrt(ptot*ptot+mass*mass);
      }
      if(current.evnt%steer.nevfreq==0) {
        printf("  particle 4-momentum = %f %f %f %f\n",ev2.patt[0][k], ev2.patt[1][k], ev2.patt[2][k], ev2.patt[3][k]);
      }
    }
  }
  else if(TMath::Abs(steer.idgen)==5) {
    Int_t iev = current.evnt;
    h2034->GetEntry(iev);
    //      printf("\n **** Event no. %d\n",iev);
    //      printf("neutron multiplicity = %d\n",nmul);
    //      printf("proton multiplicity = %d\n",pmul);
    ev1.natt=0;
    if(nmul>0 && nmul<100) {
      mass = neutronmass;
      for(Int_t i=0; i<nmul; i++){
        //          printf("neutron no. %d - px,py,pz %f %f %f\n",i+1,npx[i],npy[i],npz[i]);
        ev2.katt[0][i]=2112;
        ev2.katt[1][i]=0;
        ev2.patt[0][i]=npx[i];
        ev2.patt[1][i]=npy[i];
        ev2.patt[2][i]=npz[i];
        Double_t npmod=npx[i]*npx[i]+npy[i]*npy[i]+npz[i]*npz[i];
        ev2.patt[3][i]=TMath::Sqrt(npmod+mass*mass);
      }
      if(pmul>0 && pmul<100) {
	     mass = protonmass;
        for(Int_t j=0; j<pmul; j++){
          //            printf("proton no. %d - px,py,pz %f %f %f\n",j+1,ppx[j],ppy[j],ppz[j]);
          ev2.katt[0][nmul+j]=2212;
          ev2.katt[1][nmul+j]=0;
          ev2.patt[0][nmul+j]=ppx[j];
          ev2.patt[1][nmul+j]=ppy[j];
          ev2.patt[2][nmul+j]=ppz[j];
          Double_t ppmod=ppx[j]*ppx[j]+ppy[j]*ppy[j]+ppz[j]*ppz[j];
          ev2.patt[3][nmul+j]=TMath::Sqrt(ppmod+mass*mass);
        }
      }
      ev1.natt=nmul+pmul;
      
    } else{
        printf("no neutron produced in this event!\n");
        printf("number of produced protons = %d\n",pmul);
    }
    if(current.evnt%steer.nevfreq==0) {
      printf("---- Event no. %d  with %d particles\n",current.evnt,ev1.natt);
      for (Int_t k=0; k<ev1.natt; k++){
        printf("katt = %d  -  4mom %f %f %f %f\n",ev2.katt[0][k],ev2.patt[0][k],ev2.patt[1][k],ev2.patt[2][k],ev2.patt[3][k]);
      }
	  }
  }
  /*
      else if(TMath::Abs(steer.idgen)==6) {
  //
  //  read one FLUKA event from file fp and fill two structures 
  //  the same structures used by HIJING (equivalent of the fortran common blocks)
  //
          nword=fread(&lenrec_byte, sizeof(Int_t), 1, fev); //first word of the record
  //	printf(" lunghezza record in bytes = %d\n",lenrec_byte);
    nwords_rec=lenrec_byte/4;
  //	printf("number of words in the first record = %d\n",nwords_rec);
          pointer_h1=&multipl[0];
          nword=fread(pointer_h1, sizeof(Int_t), nwords_rec, fev);
          nword=fread(&lenrec_byte, sizeof(Int_t), 1, fev); //last word of the record
  //	printf(" molteplicita totale = %d  -  ptls with eta >4 = %d\n",multipl[0],multipl[1]);
    ev1.nmul=multipl[0];
    ev1.natt=multipl[1];

          nword=fread(&lenrec_byte, sizeof(Int_t), 1, fev); //first word of the record
  //	printf(" lunghezza record in bytes = %d\n",lenrec_byte);
  //	nwords_rec=(lenrec_byte-4)/8+1;
    npart=lenrec_byte/36;
  //	printf("no. of words from record length = %d\n",npart);
    for(i=0;i<npart;i++){
      pointer_h2=&ids[0];
      nword=fread(pointer_h2, sizeof(Int_t),1,fev);
      ev2.katt[1][i]=ids[0];
      if(ids[0]>0) {
        kk=ids[0]-1;
        kpdg = kpdgcode[kk];}
      else {
        kpdg=ids[0]; 
      }
      ev2.katt[0][i]=kpdg;
  //	  printf(" --- particle no. %d - pdgcode=%d - flukacode=%d\n",i,ev2.katt[0][i],ev2.katt[1][i]);
  //	  ev2.katt[1][i]=ids[1];
      point2_h2=&pmom2[0];
      nword=fread(point2_h2, sizeof(Double_t),4,fev);
      ev2.patt[0][i]=pmom2[0];
      ev2.patt[1][i]=pmom2[1];
      ev2.patt[2][i]=pmom2[2];
      ev2.patt[3][i]=pmom2[3];
  //	  printf("     4mom= %f %f %f %f\n",pmom2[0],pmom2[1],pmom2[2],pmom2[3]);
    }
          nword=fread(&lenrec_byte, sizeof(Int_t), 1, fev); //last word of the record
  //store the generator relevant variables
            gene_t.idgene=TMath::Abs(steer.idgen);
      gene_t.prod_ptl=ev1.nmul;
      gene_t.cons_ptl=ev1.natt;
      }
  */
  else if(TMath::Abs(steer.idgen)==7) {
    //
    //  read one PYTHIA event from file fev and fill two structures 
    //  (equivalent of the fortran common blocks)
    //
    ierr = ReadPYTEvnt();
    //    printf("after reading one PYTHIA event: ierr = %d\n",ierr);
  	  	  
    //store the generator relevant variables
    gene_t.idgene=TMath::Abs(steer.idgen);
    gene_t.cons_ptl=ev1.natt;

    if(current.evnt%steer.nevfreq==0) {
      printf("*****  Event no. %d\n",current.evnt);
      printf("PYTHIA event\n");
            printf("molteplicita' di particelle = %d\n", ev1.natt);
      for(Int_t j=0; j<ev1.natt; j++){
        printf("part. no. %d:  kPyt = %d %d \n",j,ev2.katt[0][j],ev2.katt[1][j]);
        printf("  pPyt = %f %f %f %f\n",ev2.patt[0][j],ev2.patt[1][j],ev2.patt[2][j],ev2.patt[3][j]);
      }
    }
	
  }
}

//_____________________________________________________________________________
void AddAngle(Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t *angleSum)
{
	// Calculating the sum of 2 angles
	Double_t temp, cx, cy, cz, ct1, st1, ct2, st2, cp1, sp1, cp2, sp2;
	Double_t rtetsum, fisum;
	
	ct1 = TMath::Cos(theta1);
	st1 = TMath::Sin(theta1);
	cp1 = TMath::Cos(phi1);
	sp1 = TMath::Sin(phi1);
	ct2 = TMath::Cos(theta2);
	st2 = TMath::Sin(theta2);
	cp2 = TMath::Cos(phi2);
	sp2 = TMath::Sin(phi2);
	cx = ct1*cp1*st2*cp2+st1*cp1*ct2-sp1*st2*sp2;
	cy = ct1*sp1*st2*cp2+st1*sp1*ct2+cp1*st2*sp2;
	cz = ct1*ct2-st1*st2*cp2;
	
	rtetsum = TMath::ACos(cz);
	if(rtetsum==0. || rtetsum==kPI){
	fisum = 0.;
	return;
	}
	temp = cx/TMath::Sin(rtetsum);
	if(temp>1.) temp=1.;
	if(temp<-1.) temp=-1.;
	fisum = TMath::ACos(temp);
	if(cy<0) {fisum = k2PI-fisum;}
	angleSum[0] = rtetsum;
	angleSum[1] = fisum;
}

//_____________________________________________________________________________
void BeamDiv(Double_t *pLab)
{
	// Applying beam divergence
	//
	Double_t tetpart, fipart, tetdiv=0, fidiv=0, angleSum[2], tetsum, fisum;
	Double_t rvec;
	
	Double_t pmq = 0.;
	Int_t i;
	for(i=0; i<=2; i++) pmq = pmq+pLab[i]*pLab[i];
	Double_t pmod = TMath::Sqrt(pmq);
		
	rvec = gRandom->Gaus(0.0,1.0);
	tetdiv = inibeam.theta_div * TMath::Abs(rvec);
	fidiv = (gRandom->Rndm())*k2PI;
  //	printf(" theta div in rad = %f  - phi div in rad = %f\n",tetdiv,fidiv);

	tetpart = TMath::ATan2(TMath::Sqrt(pLab[0]*pLab[0]+pLab[1]*pLab[1]),pLab[2]);
	if(pLab[1]!=0. || pLab[0]!=0.) fipart = TMath::ATan2(pLab[1],pLab[0]);
	else fipart = 0.;
	if(fipart<0.) {fipart = fipart+k2PI;}
  //	printf(" theta ptl in rad = %f  - phi ptl in rad = %f\n",tetpart,fipart);
	AddAngle(tetpart,fipart,tetdiv,fidiv,angleSum);
	tetsum = angleSum[0];
	fisum = angleSum[1];
	pLab[0] = pmod*TMath::Sin(tetsum)*TMath::Cos(fisum);
	pLab[1] = pmod*TMath::Sin(tetsum)*TMath::Sin(fisum);
	pLab[2] = pmod*TMath::Cos(tetsum);
}
	
//_____________________________________________________________________________
	void FermiTwoGaussian(Double_t A)
	{
	//
	// Momenta distributions according to the "Double_t-gaussian"
	// distribution (Ilinov) - equal for protons and neutrons
	//
	
	Double_t sig1 = 0.113;
	Double_t sig2 = 0.250;
	Double_t alfa = 0.18*(TMath::Power((A/12.),(Double_t)1/3));
	Double_t xk = (2*k2PI)/((1.+alfa)*(TMath::Power(k2PI,1.5)));
	
	for(Int_t i=1; i<=200; i++){
	Double_t p = i*0.005;
	fermi.fPp[i] = p;
	Double_t e1 = (p*p)/(2.*sig1*sig1);
	Double_t e2 = (p*p)/(2.*sig2*sig2);
	Double_t f1 = TMath::Exp(-(e1));
	Double_t f2 = TMath::Exp(-(e2));
	Double_t probp = xk*p*p*(f1/(TMath::Power(sig1,3.))+
	alfa*f2/(TMath::Power(sig2,3.)))*0.005;
	fermi.fProbInt_tp[i] =fermi. fProbInt_tp[i-1] + probp;
	fermi.fProbInt_tn[i] = fermi.fProbInt_tp[i];
	}
/*
	printf("\n\n Initialization of Fermi momenta distribution \n");
	for(Int_t i=0; i<=200; i++)
	 printf(" fProbInt_tp[%d] = %f, fProbInt_tn[%d] = %f\n",i,fermi.fProbInt_tp[i],i,fermi.fProbInt_tn[i]);
*/
	}

//_____________________________________________________________________________
	void ExtractFermi(Int_t id, Double_t *ddp)
	{
	//
	// Compute Fermi momentum for spectator nucleons
	//
	
	Int_t index=0;
	Double_t xx = gRandom->Rndm();
	if(id==kProton){
	for(Int_t i=1; i<=200; i++){
	if((xx>=fermi.fProbInt_tp[i-1]) && (xx<fermi.fProbInt_tp[i])) break;
	index = i;
	}
	}
	else if(id==kNeutron){
	for(Int_t i=1; i<=200; i++){
	if((xx>=fermi.fProbInt_tn[i-1]) && (xx<fermi.fProbInt_tn[i])) break;
	index = i;
	}
	}
	Double_t pext = fermi.fPp[index]+0.001;
	Double_t phi = k2PI*(gRandom->Rndm());
	Double_t cost = (1.-2.*(gRandom->Rndm()));
	Double_t tet = TMath::ACos(cost);
	ddp[0] = pext*TMath::Sin(tet)*TMath::Cos(phi);
	ddp[1] = pext*TMath::Sin(tet)*TMath::Sin(phi);
	ddp[2] = pext*cost;
	
	printf("\nExtraction of Fermi momentum\n");
	printf("pxFermi = %f pyFermi = %f pzFermi = %f \n",ddp[0],ddp[1],ddp[2]);
}

//_____________________________________________________________________________
Double_t EdgeLoss(Int_t idcalo, Int_t ihad, Double_t *distx, Double_t *disty){
//  function used for the edge effect ==> arctan function 
//  parameters from Geant3 fortran slow simulation
//  all the lengths are in meters 

Double_t par[4];
Double_t par2,par3;
Double_t coord_sign;

// taken from nfull_fromip.root
const Double_t parh_zn[4]={-3.14, 2.68, 11.4, 3.93}; 
// taken from g0-4000_fromip.root
const Double_t parem_zn[4]={-6.91, 5.05, 132.5, 3.58};
// taken from pzp_flat.root - h306 of macro checksim_zp_2023.C
const Double_t parh_zp[4]={-15.7, 10.7, 35.8, 11.7};
// taken from egzp0-4000_flat.root - h306 of macro checksim_zp_2023.C
const Double_t parem_zp[4]={-5.19, 3.82, 64.1, 11.3};
const Double_t par3y_zp = 6.5;

  Double_t x = *distx*100.;
  Double_t y = *disty*100.;

  /*printf("****  in function EdgeLoss: idcalo = %d\n",idcalo);
  printf(" ihadFlag = %d\n",ihad);
  printf(" in detector frame: x = %f, y = %f\n",x,y);*/
  
  if(idcalo==0){
    //  ZN parameters
    if(ihad == 1) {
       for(Int_t i=0; i<4; i++) par[i]=parh_zn[i];
    } else {
       for(Int_t i=0; i<4; i++) par[i]=parem_zn[i];
    }
  } else {
    //  ZP parameters
    if(ihad == 1) {
       for(Int_t i=0; i<4; i++) par[i]=parh_zp[i];
    } else {
       for(Int_t i=0; i<4; i++) par[i]=parem_zp[i];
    }
  }
  coord_sign = 1.0;  
  if(x > 0.) {
    coord_sign = -1.0;
  }
  par2 = par[2]*coord_sign;
  par3 = par[3]*coord_sign;
  Double_t lossx = par[0]+par[1]*atan(par2*(x+par3));
/*
  printf("sign of x coord = %f\n",coord_sign);
  printf(" par = %f  %f  %f  %f\n",par[0],par[1],par2,par3);
  printf(" lossx = %f\n",lossx);
*/
  coord_sign = 1.0;  
  if(y > 0.) {
    coord_sign = -1.0;
  }
  par2 = par[2]*coord_sign;
  par3 = par[3]*coord_sign;
  if(idcalo == 1) par3 = par3y_zp*coord_sign;
  Double_t lossy = par[0]+par[1]*atan(par2*(y+par3));
/*
  printf("sign of y coord = %f\n",coord_sign);
  printf(" par = %f  %f  %f  %f\n",par[0],par[1],par2,par3);
  printf(" lossy = %f\n",lossy);
*/
  if(lossx>1.0) lossx = 1.0;
  if(lossy>1.0) lossy = 1.0;

  Double_t EdgeLoss = lossx*lossy;

  //printf("\n lossx = %f  -  lossy = %f  -> ",lossx,lossy);
  //printf(" edge loss = %f \n\n",EdgeLoss);
  
  return EdgeLoss;
}

//_____________________________________________________________________________
Double_t showpr_zn(Double_t *x, Double_t *par_zn)
{
   Double_t xx =x[0];
      Double_t p3=par_zn[1]*TMath::Log(100.)/TMath::Log(par_zn[3]);
      p3=p3/1.5;
      Double_t f = (par_zn[0]*par_zn[1])/(1.+(xx*p3-par_zn[2])*(xx*p3-par_zn[2]));
   return f;
}

//_____________________________________________________________________________
Double_t showpr_zp(Double_t *x, Double_t *par_zp)
{
  Double_t xx =x[0];
  Double_t p3=par_zp[1]*TMath::Log(100.)/TMath::Log(par_zp[3]);
  p3=p3/1.5;
  Double_t f = (par_zp[0]*par_zp[1])/(1.+(xx*p3-par_zp[2])*(xx*p3-par_zp[2]));
  return f;
}

//_____________________________________________________________________________
Double_t eshowpr_zn(Double_t *x, Double_t *epar_zn)
{
      Double_t xx =x[0];
      Double_t p3=epar_zn[1]*TMath::Log(500.)/TMath::Log(epar_zn[2]);
      p3=p3/1.5;
      Double_t f = (epar_zn[0]*epar_zn[1])/(1.+(xx*p3)*(xx*p3));
   return f;
}

//_____________________________________________________________________________
Double_t eshowpr_zp(Double_t *x, Double_t *epar_zp)
{
      Double_t xx =x[0];
      Double_t p3=epar_zp[1]*TMath::Log(500.)/TMath::Log(epar_zp[2]);
      p3=p3/1.5;
      Double_t f = (epar_zp[0]*epar_zp[1])/(1.+(xx*p3)*(xx*p3));
   return f;
}

//_____________________________________________________________________________
void pheZN (Int_t ihadFlag,  Int_t sflFlag, Double_t *KinVect, Double_t phepm[]) 
{
//
// ZN is considered 
// try to simulate number of photoelectrons in the quadrants
// from energy to total number of photoelectrons
// input parameters: 
// KinVect           track kinematical variables on calorimeter front face
// ihadflag          = 1 hadron ; =0 em shower
// sflFlag	     = 1 neutron is interacting in the beam pipe
// output parameters:
// phepm[5]          no. of photoelectrons in each PMT
//
//

// matrices used to find the number of photoelectrons in towers
TVectorD bzn(3);
TVectorD czn(3);

//  constants to evaluate the number of photoelectrons starting from 
//  particle energy entering into ZN 
//  fits are performed on results of macro phedistr_zn_2021.C on 
//  simulated data in file n2760_sidea.root
//  from vertex energy to <phe>=(qc+sumq)/2 - straight line fit
//  when neutrons do not interact in the beam pipe before entering the calo
static const Double_t pheh_zn[3] = {-193.6, 0.6737};
// mean number of phe as a function of neutron energy when neutrons interact
// in the beam pipe cone 
// from nfull_fromip.root (pol1 fit)
static const Double_t pheh_ene_int[2] = {-3.8, 1.29};

// phee_zn --> mean number of phe vs ene (em ptl in ZN)
// straight line fit on simulated data g0-4000_fromip.root
static const Double_t phee_zn[2] = {-0.885, 0.8473};
// mean number of phe as a function of gamma energy when gammas interact
// in the beam pipe cone 
// from g0-4000_fromip_0-7.root (pol1 fit)
static const Double_t phee_ene_int[2] = {10.3, 1.26};

// non uniform response of ZN for em ptl in ZN; function is pol2
// the parameters are the mean of fits to h47 and h48 in macro
// phedistr_zn_2021.C  -  data are from g0-4000_fromip.root (sfl=0)
Double_t notunif = 0., signuni = 0.; 
static const Double_t par_uni_ezn[3] = {0.546, 10.69, -51.49};

//  number of photoelectrons produced in the naked fibres beyond ZN 
//  normalized to sumq_av ( = sumqnf/sumq_av)
//  is fitted as a second order polymonial as a function of x (horizontal coord
//  in the ZN reference frame) - from nfull_fromip.root
static const Double_t sumqnfnorm_vs_x[3] = {0.036, -0.0048, 0.0196};  
static const Double_t qcnfnorm_vs_x[3] = {0.070, -0.00093, 0.0051};  
//  the ratio phe(i)/sumqnf for i = 1 and 3 can be fitted with a 
//  third order polynomial as function of x  
//  The best parameters are for PMT1 and for PMT3:
//  (0.28, -0.061, -0.00197, 0.0004)
//  while for PMT2 and PMT4 : 
//  (0.22, 0.039, 0.00197, -0.0004)
static const Double_t coef_znnf_odd[4] = {0.22, 0.039, 0.00197, -0.0004};
static const Double_t coef_znnf_even[4] = {0.28, -0.061, -0.00197, 0.0004};

//  number of photoelectrons produced in the naked fibres beyond ZP 
//  normalized to sumq_av ( = sumtnf/sumq_av)
//  is fitted as a second order polymonial as a function of x 
//  (horizontal coord in the ZN reference frame). 
//  from  nfull_fromip.root 
static const Double_t sumtnfnorm_vs_x[3] = {0.013, 0.0059, 0.0034};
//  number of photoelectrons produced in the naked fibres beyond ZP 
//  normalized to sumq_av ( = tcnf/sumq_av)
//  is fitted with atan as a function of x 
//  (horizontal coord in the ZN reference frame). 
static const Double_t tcnfnorm_vs_x[4] = {0.52, 0.32, -7.77, 3.54};
//  Sharing of phes among ZP towers can be fitted 
//  approximately as a straight line
//  t4nfnorm => pol1: (0.29, 0.0012)
//  t3nfnorm => pol1: (0.20, 0.0038)
//  t2nfnorm => pol1: (0.20, -0.0013)
//  t1nfnorm => pol1: (0.29, -0.0013)
static const Double_t coef_zpnf[4][2] = {0.29,-0.0013, 0.20,-0.0013, 0.20,0.0038, 0.29,0.0012};

//  the number of photoelectrons produced in ZP (fibres in calo)
//  (crosstalk) is fitted as an atan function as a function of x
//  TF1 *xtalkonzp = new TF1("xtalkonzp","[0]+[1]*atan([2]*(x+[3]))",-3.5,3.5);
//  parameters of the function:
static const Double_t par_sumtnorm[4] = {0.51, 0.33, 7.14, -3.9};
static const Double_t par_tcnorm[4] = {0.51, 0.32, 7.74, -3.53};
//  Sharing of phes among ZP towers can be fitted as a pol2
//  t4norm => pol2: (0.025, 0.0025, -0.00036)
//  t3norm => pol2: (0.070, -0.0047, -0.0041)
//  t4norm => pol2: (0.20, -0.0073, -0.0023)
//  t1norm => pol2: (0.70, 0.015, 0.0078)
static const Double_t coef_zp[4][3] = {0.70,0.015,0.0078, 0.20,-0.0073,-0.0023, 0.070,-0.0047,-0.0041, 0.025,0.0025,-0.00036};

static const Double_t LambdaZN = 11.5; // ZN interaction length in cm
static const Double_t Chi0ZN = 0.398; // ZN radiation length in cm

static const Double_t xpitch = 0.16; // fibre spacing along x coord. 
static const Double_t ypitch = 0.16; // fibre spacing along y coord.

Double_t par_q1q3[4] = {0.,}, par_q1q2[4] = {0.,}, par_q2q3[4] = {0.,};
Double_t phetot = 0., phesum = 0., phec = 0.;
Double_t sumq_av = 0., sumq = 0., qc = 0.;
Double_t sumqnf = 0., qcnf = 0., sumtnf = 0., tcnf = 0.;
Double_t sumtxtalk = 0., tcxtalk = 0.;
Double_t eneres1 = 0.;
Double_t eneres2 = 0.;

Double_t showmax = 0.;
Double_t q[4] = {0.,};

// change coordinate units from meters to centimeters
Double_t x = (KinVect[0] - geom.xczn[current.iside])*100.;
Double_t y = (KinVect[1] - geom.yczn[current.iside])*100.;
Double_t ux = KinVect[3];
Double_t uy = KinVect[4];
Double_t energy = KinVect[6];
Double_t hx = geom.hxzn[current.iside]*100.;
Double_t hy = geom.hyzn[current.iside]*100.;
/*if(current.evnt%steer.nevfreq == 0){
  printf(" in ZN frame: x = %f cm - y = %f cm ",x,y);
  printf(" ux = %f - uy = %f\n",ux,uy);
  printf(" released energy = %f\n",energy);
}*/

//  calculate distance of impact point from closest fibre
 Double_t fibx = (x+hx)/xpitch;
 Int_t ifibx = (Int_t) fibx;
 Double_t xfib = (ifibx*xpitch+xpitch*0.5)-hx;
 Double_t dxtofib = x-xfib;
 Double_t fiby = (y+hy)/ypitch;
 Int_t ifiby = (Int_t) fiby;
 Double_t yfib = (ifiby*ypitch+ypitch*0.5)-hy;
 Double_t dytofib = y-yfib;
 Double_t dtofib = sqrt(dxtofib*dxtofib + dytofib*dytofib);

if(ihadFlag == 1){ 
//  phetot is the number of phe on PMC or sumoftowers
      if(sflFlag == 0) {
       phetot=(pheh_zn[0]+pheh_zn[1]*energy+pheh_zn[2]*energy*energy);
      } else {
       phetot=pheh_ene_int[0]+pheh_ene_int[1]*energy;
      }
      /*if(current.evnt%steer.nevfreq == 0) {
        printf(" sflFlag = %d - phetot = %f\n",sflFlag,phetot);
      }*/
       eneres1=steer.ZNhadSigmaRes[0];
       eneres2=steer.ZNhadSigmaRes[1];
       showmax = LambdaZN*1.1;
       for(Int_t i=0; i<4;i++) {
         par_q1q2[i] = hpar_q1q2[i];
         par_q1q3[i] = hpar_q1q3[i];
         par_q2q3[i] = hpar_q2q3[i];
       }
} else {
      if(sflFlag == 0) {
       sumq_av=(phee_zn[0]+energy*phee_zn[1]);
      } else {
       sumq_av=(phee_ene_int[0]+energy*phee_ene_int[1]);
      }
// code for disuniformity in the response due to fibre distance
      Double_t par_uni[4];
       if(((ifibx%2 == 0) && (ifiby%2 == 0)) || ((ifibx%2 != 0) && (ifiby%2 != 0))) {
         signuni = 1.0;
       } else {
         signuni = -1.0;
       }
       par_uni[0] = 1. - signuni*par_uni_ezn[0];
       for(int i=1; i<3; i++) par_uni[i] = signuni * par_uni_ezn[i];
       notunif = par_uni[0]+par_uni[1]*dtofib+par_uni[2]*dtofib*dtofib+par_uni[3]*dtofib*dtofib*dtofib;

       sumq = sumq_av * notunif;
       qc = 2.0 * sumq_av - sumq;
       /*if(current.evnt%steer.nevfreq == 0) {
        printf(" sflFlag = %d - sumq_av = %f\n",sflFlag,sumq_av);
        printf(" sumq = %f - qc = %f\n",sumq,qc);
       }*/
       eneres1=steer.ZNemSigmaRes[0];
       eneres2=steer.ZNemSigmaRes[1];
       showmax = Chi0ZN*10.;
       for(Int_t i=0; i<4;i++) {
         par_q1q2[i] = epar_q1q2[i];
         par_q1q3[i] = epar_q1q3[i];
         par_q2q3[i] = epar_q2q3[i];
       }
}

//  redefine coordinates to go where the shower is maximum
  Double_t xn=x+ux*showmax;
  if(TMath::Abs(xn)>hx) xn = copysign(hx,xn);
  Double_t yn=y+uy*showmax;
  if(TMath::Abs(yn)>hy) yn = copysign(hy,yn);
  /*if(current.evnt%steer.nevfreq == 0) {
   printf(" coordinates of maximum shower: xn = %f, yn = %f\n",xn,yn);
  }*/
	
//  add statistical fluctuations on the phe number
Double_t res = TMath::Sqrt(eneres1*eneres1/energy+eneres2*eneres2);
Double_t fluctpc = res*TMath::Sqrt2();
Double_t fluct = fluctpc*phetot;

if(ihadFlag == 1){ 
  phesum = gRandom->Gaus(phetot,fluct);
  if(phesum < 0.0) phesum = 0.0;
  phec = gRandom->Gaus(phetot,fluct);
  if(phec < 0.0) phec = 0.0;
} else {
  phesum = gRandom->Gaus(sumq,fluct);
  if(phesum < 0.0) phesum = 0.0;
  phec = gRandom->Gaus(qc,fluct);
  if(phec < 0.0) phec = 0.0;
}
/*if(current.evnt%steer.nevfreq==0){
  printf(" in pheZN: pc in ZN, ihadFlag = %d\n",ihadFlag);
  printf(" phe on pmc =%f, phesum = %f\n",phec,phesum);
}*/

//define vector
bzn(0) = par_q1q3[0]+par_q1q3[1]*TMath::ATan(par_q1q3[2]*(xn+par_q1q3[3]));
bzn(1) = par_q1q2[0]+par_q1q2[1]*TMath::ATan(par_q1q2[2]*(yn+par_q1q2[3]));
bzn(2) = par_q2q3[0]+par_q2q3[1]*TMath::ATan(par_q2q3[2]*(xn*yn+par_q2q3[3]));
czn = azn*bzn;
/*if(current.evnt%steer.nevfreq == 0) {
  printf("normalized q1+q3 = %f\n",bzn(0));
  printf("normalized q1+q2 = %f\n",bzn(1));
  printf("normalized q2+q3 = %f\n",bzn(2));
//  bzn.PrInt_t();
  czn.Print();
}*/
phepm[0] = phec;
phepm[1] = phesum*czn(0);
phepm[2] = phesum*czn(1);
phepm[3] = phesum*czn(2);
phepm[4] = phesum-phepm[1]-phepm[2]-phepm[3];
for(Int_t i=0; i<5; i++) {
  if(phepm[i]<0.) phepm[i]=0.;
  //if(current.evnt%steer.nevfreq==0) printf(" in pheZN:  phe[%d] = %f\n",i,phepm[i]);
} 

}

//_____________________________________________________________________________
void pheZP (Int_t ihadFlag, Int_t sflFlag, Double_t *KinVect, Double_t phepm[]) 
{
//
// ZP is considered
// try to simulate number of photoelectrons in the quadrants from energy 
// input parameters: 
// KinVect           track kinematical variables on calorimeter front face 
// KinVect[6] => energy in ZP after edge correction for sflFlag=1
// ihadFlag          = 1 hadron shower; =0 em shower
// sflFlag	     = 1 particle has interacted in the beam pipe
// output parameters:
// phepm[5]          no. of photoelectrons in each PMT
//
 
TVectorD bzp(3);
TVectorD czp(3);
Double_t par_t1[4],par_t1t2[4],par_t1t2t3[4];
Double_t phetot;
Double_t eneres1;
Double_t eneres2;
Double_t showmax;
Double_t par_uni[4];

static const Double_t towersize = 0.056; 
static const Double_t LambdaZP = 18.4; // ZP interaction length in cm
static const Double_t Chi0ZP = 1.50; // ZP radiation length in cm
static const Double_t xpitch = 0.4; // fibre spacing along x coord. 
static const Double_t ypitch = 0.4; // fibre spacing along y coord.
static const Double_t thr_dtofib = 0.26;

// ====== parametes for protons ========================
// mean number of phe as a function of GEANT3 released proton energy 
// from ~/fmc/truesidea/ptot.root (pol2 fit)
const Double_t phe_ene_zp[3] = { -1.78, 0.85, 3.5e-06 }; 
// mean number of phe as a function of proton energy when protons interact
// in the beam pipe cone 
// from p0-5000_fromip_cor.root (pol1 fit)
const Double_t phe_ene_int[2] = {-1.68, 0.857};
//  correction to take into account the GEANT3 released energy 
//  and the shower leakage at the lateral edges
//  from simulation file ~/fmc/truesidea/pzp_flat.root with |y|<2.0 cm
Double_t fromEtoG3ene_h = 0.61;
Double_t notunif,signuni; 
// non uniform response of ZP for hadronic ptl; function is (1. +/- expo)
//const Double_t disunif_h[2] = {-2.51,  -11.2};
// non uniform response of ZP for hadronic ptl; function is pol2
// from ~/fmc/truesidea/ptot.root
const Double_t disunif_h[3] = { 0.048, 0.1157, 1.271};
 
// ====== parametes for em particles ========================
// to go from energy to G3 energy for em ptl 
// from egzp0-4000_flat.root 
Double_t fromEtoG3ene_em = 0.808;
// mean number of phe as a function of Geant3 released energy 
// from ezp0-4000_flat.root (pol1 fit)
const Double_t phee_zp[2] = {0.269, 0.886}; 
// non uniform response of ZP for em ptl; function is a pol3
// from ezp0-4000_flat.root (fit to h45)
Double_t par_uni_ezp[3] = {0.154, -0.00447, 4.11 };

// change coordinate units from meters to centimeters
Double_t x = (KinVect[0]-geom.xczp[current.iside])*100.;
Double_t y = (KinVect[1]-geom.yczp[current.iside])*100.;
Double_t ux = KinVect[3];
Double_t uy = KinVect[4];
Double_t energy = KinVect[6];
Double_t hx = geom.hxzp[current.iside]*100.;
Double_t hy = geom.hyzp[current.iside]*100.;
if(current.evnt%steer.nevfreq == 0) {
  printf(" in ZP frame: x = %f cm - y = %f cm\n",x,y);
  printf(" ux = %f - uy = %f\n",ux,uy);
  printf(" released energy = %f\n",energy);
}

//  calculate distance of impact point from closest fibre
 Double_t fibx = (x+hx)/xpitch;
 Int_t ifibx = (Int_t) fibx;
 Double_t xfib = (ifibx*xpitch+xpitch*0.5)-hx;
 Double_t dxtofib = x-xfib;
 Double_t fiby = (y+hy)/ypitch;
 Int_t ifiby = (Int_t) fiby;
 Double_t yfib = (ifiby*ypitch+ypitch*0.5)-hy;
 Double_t dytofib = y-yfib;
 Double_t dtofib = sqrt(dxtofib*dxtofib + dytofib*dytofib);

if(ihadFlag == 1){
//  parametrization for hadrons 
//  parametrize the GEANT3 released energy taking into account
//  the shower lateral leakage 
//  phetot is the mean number of phe  (PMC+sumoftowers)/2
      if(sflFlag == 0) {
       Double_t ene_G3 = fromEtoG3ene_h * energy;
       phetot=phe_ene_zp[0]+phe_ene_zp[1]*ene_G3+phe_ene_zp[2]*ene_G3*ene_G3;
      } else {
       phetot=phe_ene_int[0]+phe_ene_int[1]*energy;
      }
       eneres1=steer.ZPhadSigmaRes[0];
       eneres2=steer.ZPhadSigmaRes[1];
       showmax = LambdaZP*1.1;
// code for disuniformity in the response due to fibre distance
       if(((ifibx%2 == 0) && (ifiby%2 == 0)) || ((ifibx%2 != 0) && (ifiby%2 != 0))) {
         signuni =  1.0;
       } else {
         signuni = -1.0;
       }
       par_uni[0] = 1. - signuni*disunif_h[0];
       for(int i=1; i<3; i++) par_uni[i] = signuni * disunif_h[i];
//       for(int i=0; i<3; i++) printf("par_uni[%d] = %f\n",i,par_uni[i]);
       notunif = par_uni[0]+par_uni[1]*dxtofib+par_uni[2]*dxtofib*dxtofib;
//        notunif = 1. - signuni * exp(disunif_h[0]+disunif_h[1]*dtofib);
//
       for(int i=0; i<4; i++) {
         par_t1[i] = hpar_t1[i];
         par_t1t2[i] = hpar_t1t2[i];
         par_t1t2t3[i] = hpar_t1t2t3[i];
       }
}
else {
//  parametrization for electrons/positrons/gammas
//  parametrize the GEANT3 released energy taking into account
//  the shower lateral leakage 
       Double_t ene_G3 = fromEtoG3ene_em * energy;
       phetot=phee_zp[0] + ene_G3 * phee_zp[1];
       eneres1=steer.ZPemSigmaRes[0];
       eneres2=steer.ZPemSigmaRes[1];
       showmax = Chi0ZP*10.;
// code for disuniformity in the response due to fibre distance
       if(((ifibx%2 == 0) && (ifiby%2 == 0)) || ((ifibx%2 != 0) && (ifiby%2 != 0))) {
         signuni = 1.0;
       } else {
         signuni = -1.0;
       }
       par_uni[0] = 1. - signuni*par_uni_ezp[0];
       for(int i=1; i<4; i++) par_uni[i] = signuni * par_uni_ezp[i];
//	for(int i=0; i<4; i++)printf("par_uni[%d] = %f\n",i,par_uni[i]);
//       if(dtofib < thr_dtofib) {
         notunif = par_uni[0]+par_uni[1]*dtofib+par_uni[2]*dtofib*dtofib+par_uni[3]*dtofib*dtofib*dtofib;
//       } else {
//         notunif = 1.0;
//       }
       
       for(Int_t i=0; i<4;i++) {
         par_t1[i] = epar_t1[i];
         par_t1t2[i] = epar_t1t2[i];
         par_t1t2t3[i] = epar_t1t2t3[i];
       }
}

//  redefine coordinates to go where the shower is maximum
  Double_t xn=x+ux*showmax;
  if(TMath::Abs(xn)<hx) {
    x=xn;
  } else {
    if(xn>0.) x = hx;
    if(xn<0.) x =-hx;
  } 
  Double_t yn=y+uy*showmax;
  if(TMath::Abs(yn)<hy) {
    y=yn;
  } else {
    if(yn>0.) y = hy;
    if(yn<0.) y =-hy;
  } 
  /*if(current.evnt%steer.nevfreq == 0) {
     printf(" coordinates of maximum shower: xn = %f, yn = %f\n",xn,yn);
     printf(" redefinition of coordinates: x = %f, y = %f\n",x,y);
  }*/

//  add statistical fluctuations on the phe number
Double_t res = TMath::Sqrt(eneres1*eneres1/energy+eneres2*eneres2);
Double_t fluctpc = res*TMath::Sqrt2();
Double_t fluct = fluctpc*phetot;
Double_t phesum = phetot*notunif;
Double_t phec = 2.0 * phetot - phesum;
phesum = gRandom->Gaus(phesum,fluct);
if(phesum < 0.0) phesum = 0.0;
phec = gRandom->Gaus(phec,fluct);
if(phec < 0.0) phec = 0.0;
if(current.evnt%steer.nevfreq==0){
  printf("in pheZP: ptl in ZP, ihadFlag = %d\n",ihadFlag);
  printf("phetot= %f - fluct= %f\n",phetot,fluct);
  printf("ifibx = %d - ifiby = %d\n",ifibx,ifiby);
  printf("dxtofib  = %f - dytofib = %f - dtofib = %f\n",dxtofib,dytofib,dtofib);
  printf("phe on pmc =%f, phesum = %f\n",phec,phesum);
}
//define vector
bzp(0) = par_t1[0]+par_t1[1]*TMath::ATan(par_t1[2]*(x+par_t1[3]));
bzp(1) = par_t1t2[0]+par_t1t2[1]*TMath::ATan(par_t1t2[2]*(x+par_t1t2[3]));
bzp(2) = par_t1t2t3[0]+par_t1t2t3[1]*TMath::ATan(par_t1t2t3[2]*(x+par_t1t2t3[3]));
/*if(current.evnt%steer.nevfreq == 0) {
  printf("normalized t1 = %f\n",bzp(0));
  printf("normalized t1+t2 = %f\n",bzp(1));
  printf("normalized t1+t2+t3 = %f\n",bzp(2));
}*/
if((bzp(1)>bzp(0)) && (bzp(2)<bzp(1))) bzp(2) = bzp(1);
czp = azp*bzp;
if(current.evnt%steer.nevfreq == 0) {
  bzp.Print();
  czp.Print();
}
phepm[0] = phec;
phepm[1] = phesum*czp(0);
phepm[2] = phesum*czp(1);
phepm[3] = phesum*czp(2);
phepm[4] = phesum-phepm[1]-phepm[2]-phepm[3]; 
for(Int_t i=0; i<5; i++) {
  if(phepm[i]<0.) phepm[i]=0.;
  if(current.evnt%steer.nevfreq==0) printf(" in pheZP: tower t%d - phe = %f\n",i,phepm[i]);
} 
/*
phe_t.t1[current.iside] = phepm[1];
phe_t.t2[current.iside] = phepm[2];
phe_t.t3[current.iside] = phepm[3];
phe_t.t4[current.iside] = phepm[4];
phe_t.tc[current.iside] = phesum;
*/
}

//_____________________________________________________________________________
Double_t hsp_Int_t(Double_t xx, Double_t par[])
{
//Double_t fh = 0.5*par[0]*xx*(1-TMath::Exp(-xx));
Double_t f = par[0]*TMath::Erf(par[1]*xx);
return f;
}
//_____________________________________________________________________________
Double_t IntFun(Double_t xx, Double_t par0_IntFun, Double_t par1_IntFun)
{
Double_t t = par1_IntFun*xx;
//Double_t f = par[0]*(0.5*TMath::Sqrt(kPI)/par[1]*TMath::Erf(t)-xx*TMath::Exp(-t*t));
Double_t f = 0.5*TMath::Sqrt(kPI)/par1_IntFun*TMath::Erf(t)-xx*TMath::Exp(-t*t);
f *= 0.5*par0_IntFun/(par1_IntFun*par1_IntFun);
return f;
}
//_____________________________________________________________________________
Double_t FindInt(Double_t xf, Double_t trl){
const Double_t ptlen[16] = {0.5,2.,5.,10.,15.,20.,50.,100.,200.,300.,400.,500.,1000.,2000.,3000.,4000.};
const Double_t par0[16] = {.0063,.01392,.02485,.03949,.05213,.0637,.1223,.2031,.3409,.4635,.5775,.6858,1.1731,1.622,2.811,3.538};
const Double_t par1[16] = {.1778,.1458,.1303,.1206,.1156,.1122,.1027,.09648,.09094,.08797,.08597,.08449,.08013,.0780,.0743,.0729};
Double_t p0,p1;
//printf(" particle energy = %f  -  track length = %f\n",xf,trl);
if(xf>0.5 && xf<4000.){
for (Int_t i=0; i<15; i++) {
  if(xf==ptlen[i]){
      p0=par0[i];
      p1=par1[i];
//      printf(" xf exactly on the points\n");
//      printf(" --- i = %d - p0 = %f - p1 = %f\n",i,p0,p1);
      break;
  } else if(xf>ptlen[i] && xf<ptlen[i+1]) {
//    printf(" xf inside the range\n");
      Double_t frac = (xf-ptlen[i])/(ptlen[i+1]-ptlen[i]);
      p0=par0[i]+(par0[i+1]-par0[i])*frac;
      p1=par1[i]+(par1[i+1]-par1[i])*frac;
//      printf(" --- i = %d - p0 = %f - p1 = %f\n",i,p0,p1);
//      printf("interpolating p0 between %f and %f\n",par0[i],par0[i+1]);
//      printf("interpolating p1 between %f and %f\n",par1[i],par1[i+1]);
      break;
  }
  }
  } else if(xf<=0.5) {
      p0=par0[0];
      p1=par1[0];
//      printf(" xf = %f - p0 = %f - p1 = %f\n",xf,p0,p1);
      xf = 0.5;
  } else {
      p0=par0[15];
      p1=par1[15];
//      printf(" xf = %f - p0 = %f - p1 = %f\n",xf,p0,p1);
      xf = 4000;
  }
//  printf("parameters at this energy: par0 = %f - par1 = %f\n",p0,p1);
  Double_t val1 = IntFun(trl,p0,p1);
  Double_t val = val1;
//  printf(" value of the function = %f  - at chi0 = %f  for energy = %f\n",val,trl,xf);
  return val;
}
//_____________________________________________________________________________
Bool_t linePlaneIntersection(Double_t *Intersectpoint, TVector3 ray, TVector3 rayOrigin, TVector3 normal, TVector3 coord) {
TVector3 contact;
    // get d value
    //Double_t d = Dot(normal, coord);
/*
    printf(" vector normal to plane (normal) = %f %f %f\n",normal(0),normal(1),normal(2));
    printf(" point on plane (coord) = %f %f %f\n",coord(0),coord(1),coord(2));
    printf(" point on line (rayOrigin) = %f %f %f\n",rayOrigin(0),rayOrigin(1),rayOrigin(2));
    printf(" direction of ray (ray) = %f %f %f\n",ray(0),ray(1),ray(2));
*/    
    Double_t d = normal.Dot(coord); 
//    printf(" dot product between normal and coord = %f\n",d);

//    if (Dot(normal, ray) == 0) {
    if (normal.Dot(ray) == 0) {
//	printf(" No intersection, the line is parallel to the plane\n");
        return false; // No intersection, the line is parallel to the plane
    }

    // Compute the X value for the directed line ray intersecting the plane
    Double_t x = (d - normal.Dot(rayOrigin)) / normal.Dot(ray);
//    printf(" x =  %f\n",x);

    // output contact point
    contact = rayOrigin + ray*x; //Make sure your ray vector is normalized
//    printf(" point of inters. = %f %f %f\n",contact(0),contact(1),contact(2));
    Intersectpoint[0]=contact(0);
    Intersectpoint[1]=contact(1);
    Intersectpoint[2]=contact(2);
    return true;
}

//_____________________________________________________________________________
void checkZEM(Double_t *KinVect){

TVector3 ray,rayOrigin,normal,coord;
Double_t Intersectpoint[3];
TVector3 v1;
Bool_t a = false;
Int_t iplane=0;
const Double_t pointonPlane[6][3]={{0.061,0.0,7.60},{0.131,0.0,7.60},{0.096,-0.035,7.60},{0.096,0.035,7.60},{0.096,0.0,7.60},{0.096,0.0,7.81}};
const Double_t NormaltoPlane[6][3]={{-1.,0.0,0.0},{1.0,0.0,0.0},{0.0,-1.0,0.0},{0.0,1.0,0.0},{0.0,1.414214,-1.414214},{0.0,-1.414214,1.414214}};
const Double_t LambdaZEM = 0.1709;
const Double_t Chi0ZEM = 0.0056;
const Double_t res1ZEM = 0.88;
const Double_t res2ZEM = 0.0001;

Double_t d2m,d2M,dm,c1m,c1M,c2m,c2M;
Double_t Coord1_min = 0.; 
Double_t Coord1_max = 0.; 
Double_t Coord2_min = 0.; 
Double_t Coord2_max = 0.;
Int_t nPlaneHit = 0;
Int_t kPlaneHit[6] = {0,};
Double_t PlaneHit[6][3] = {0};
Double_t dx = 0., dy = 0., dz = 0.;
Double_t TrackLen = 0.;
Double_t trl = 0.;
Double_t energy = 0.;
Double_t par[2] = {0,}; 

Double_t xbip = KinVect[0];
Double_t ybip = KinVect[1];
Double_t zbip = KinVect[2];
Double_t px = KinVect[3];
Double_t py = KinVect[4];
Double_t pz = KinVect[5];
Double_t energy0 = KinVect[6];

//decide which ZEM could be hit
  Int_t iside=0;
  Double_t px_ori = px;
  if(px<0.0) {
    iside=1;
    px=-px;
  }
  

  rayOrigin.SetXYZ(xbip,ybip,zbip); //initial point of track
  ray.SetXYZ(px,py,pz); 
  ray = ray.Unit();  //get versor

  nPlaneHit=0;
 
  for(iplane=0; iplane<6; iplane++) {
  for (Int_t k=0; k<3; k++) PlaneHit[iplane][k]=0.0;
  if(iplane==0 || iplane==1) {
    Coord1_min = geom.yczem[0]-geom.hyzem[0];
    Coord1_max = geom.yczem[0]+geom.hyzem[0]; 
    Coord2_min = geom.distem[0];
    Coord2_max = geom.distem[0]+geom.thickzem[0]; 
  } else if(iplane==2 || iplane==3) {
    Coord1_min = geom.xczem[0]-geom.hxzem[0];
    Coord1_max = geom.xczem[0]+geom.hxzem[0]; 
    Coord2_min = geom.distem[0];
    Coord2_max = geom.distem[0]+geom.thickzem[0]; 
  } else if(iplane==4 || iplane==5) {
    Coord1_min = geom.xczem[0]-geom.hxzem[0];
    Coord1_max = geom.xczem[0]+geom.hxzem[0]; 
    Coord2_min = geom.yczem[0]-geom.hyzem[0];
    Coord2_max = geom.yczem[0]+geom.hyzem[0]; 
  }
/*
  printf(" --- plane no. %d\n",iplane);
  printf(" Coord1_min = %f  - Coord1_max = %f\n",Coord1_min,Coord1_max);
  printf(" Coord2_min = %f  - Coord2_max = %f\n",Coord2_min,Coord2_max);
*/
// define one point on each ZEM planes 
  coord.SetX(pointonPlane[iplane][0]);
  coord.SetY(pointonPlane[iplane][1]);
  coord.SetZ(pointonPlane[iplane][2]);
//  printf(" plane no. %d - coord. of a point on this plane = %f %f %f\n",iplane,pointonPlane[iplane][0],pointonPlane[iplane][1],pointonPlane[iplane][2]);
// define normal to each ZEM plane
  normal.SetX(NormaltoPlane[iplane][0]);
  normal.SetY(NormaltoPlane[iplane][1]);
  normal.SetZ(NormaltoPlane[iplane][2]);
//  printf(" plane no. %d - normal. to this plane = %f %f %f\n",iplane,NormaltoPlane[iplane][0],NormaltoPlane[iplane][1],NormaltoPlane[iplane][2]);

  a=linePlaneIntersection(Intersectpoint,ray,rayOrigin,normal,coord);
  if(a) {
//    printf(" point of intersection = %f %f %f\n",Intersectpoint[0],Intersectpoint[1],Intersectpoint[2]);
//  check if inside geometrical dimenson of ZEM

    if(iplane==0 || iplane==1) {
     d2m = Intersectpoint[2] - Coord2_min;
     d2M = Intersectpoint[2] - Coord2_max;
     dm = Intersectpoint[1];
     c1m = Coord1_min;
     c1M = Coord1_max;
     c2m = Coord2_min + dm;
     c2M = Coord2_max + dm;
     if(TMath::Abs(d2m)<geom.hyzem[0])  {
       c1M = d2m;
     } 
     if(TMath::Abs(d2M)<geom.hyzem[0])  {
       c1m = d2M;
     } 
/*
     printf("after if\n");
     printf("c1m = %f - c1M = %f\n",c1m,c1M);
     printf("c2m = %f - c2M = %f\n",c2m,c2M);
*/
    if((Intersectpoint[1]>c1m && Intersectpoint[1]<c1M)&&(Intersectpoint[2]>c2m && Intersectpoint[2]<c2M)){
//        printf(" inside plane %d - impact point = %f %f %f\n",iplane,Intersectpoint[0],Intersectpoint[1],Intersectpoint[2]);
	for(Int_t k=0; k<3; k++) PlaneHit[nPlaneHit][k]=Intersectpoint[k];
	kPlaneHit[nPlaneHit]=iplane;
	nPlaneHit++;}
    }
    if(iplane==2) {
     c1m = Coord1_min;
     c1M = Coord1_max;
     c2m = Coord2_min - geom.hyzem[0];
     c2M = Coord2_max - geom.hyzem[0];
//     printf("c1m = %f - c1M = %f\n",c1m,c1M);
//     printf("c2m = %f - c2M = %f\n",c2m,c2M);
     if((Intersectpoint[0]>c1m && Intersectpoint[0]<c1M) && (Intersectpoint[2]>c2m && Intersectpoint[2]<c2M)){
//        printf(" inside plane %d - impact point = %f %f %f\n",iplane,Intersectpoint[0],Intersectpoint[1],Intersectpoint[2]);
	for(Int_t k=0; k<3; k++) PlaneHit[nPlaneHit][k]=Intersectpoint[k];
	kPlaneHit[nPlaneHit]=iplane;
	nPlaneHit++;}
    }
    if(iplane==3) {
     c1m = Coord1_min;
     c1M = Coord1_max;
     c2m = Coord2_min + geom.hyzem[0];
     c2M = Coord2_max + geom.hyzem[0];
//     printf("c1m = %f - c1M = %f\n",c1m,c1M);
//     printf("c2m = %f - c2M = %f\n",c2m,c2M);
     if((Intersectpoint[0]>c1m && Intersectpoint[0]<c1M)&&(Intersectpoint[2]>c2m && Intersectpoint[2]<c2M)){
//        printf(" inside plane %d - impact point = %f %f %f\n",iplane,Intersectpoint[0],Intersectpoint[1],Intersectpoint[2]);
	for(Int_t k=0; k<3; k++) PlaneHit[nPlaneHit][k]=Intersectpoint[k];
	kPlaneHit[nPlaneHit]=iplane;
	nPlaneHit++;}
    }
    if(iplane==4 && (Intersectpoint[0]>Coord1_min && Intersectpoint[0]<Coord1_max)&&(Intersectpoint[1]>Coord2_min && Intersectpoint[1]<Coord2_max)){
//        printf(" inside plane %d - impact point = %f %f %f\n",iplane,Intersectpoint[0],Intersectpoint[1],Intersectpoint[2]);
	for(Int_t k=0; k<3; k++) PlaneHit[nPlaneHit][k]=Intersectpoint[k];
	kPlaneHit[nPlaneHit]=iplane;
//	printf(" nPlaneHit = %d - kPlaneHit = %d\n",nPlaneHit,kPlaneHit[nPlaneHit]);
	nPlaneHit++;}
    if(iplane==5 && (Intersectpoint[0]>Coord1_min && Intersectpoint[0]<Coord1_max)&&(Intersectpoint[1]>Coord2_min && Intersectpoint[1]<Coord2_max)){   
//        printf(" inside plane %d - impact point = %f %f %f\n",iplane,Intersectpoint[0],Intersectpoint[1],Intersectpoint[2]);
	for(Int_t k=0; k<3; k++) PlaneHit[nPlaneHit][k]=Intersectpoint[k];
	kPlaneHit[nPlaneHit]=iplane;
//	printf(" nPlaneHit = %d - kPlaneHit = %d\n",nPlaneHit,kPlaneHit[nPlaneHit]);
	nPlaneHit++;}
  } else {
//      printf(" no intersection found\n");
    }
  }  //endloop over planes
/*
  printf(" number of planes hit by track = %d\n",nPlaneHit);
  for(Int_t k=0; k<nPlaneHit;k++){
    printf(" incremental plane hit %d - plane no. %d - coord on this plane = %f %f %f\n",k,kPlaneHit[k],PlaneHit[k][0],PlaneHit[k][1],PlaneHit[k][2]);
  }
*/
  if(nPlaneHit==2) {
    dx = PlaneHit[0][0]-PlaneHit[1][0];
    dy = PlaneHit[0][1]-PlaneHit[1][1];
    dz = PlaneHit[0][2]-PlaneHit[1][2];
    TrackLen=TMath::Sqrt(dx*dx+dy*dy+dz*dz);
  } else {
    TrackLen=0.0;
  }
//  printf(" Track Length in ZEM = %f\n",TrackLen);
  if(TrackLen!=0) {
    if(current.evnt%steer.nevfreq == 0) {
      printf(" particle %d is inside ZEM\n",current.kPDGcode);
      printf(" track length = %f\n",TrackLen);
    }
//  particle hit the ZEM
//  fill the ntuple according to type of particle
     if(current.kPDGcode==2112) {
//  particle is a participant neutron
       ptlzem_t.neuzem[iside]++;
       enzem_t.eneuzem[iside]+=energy0;
     } else if(current.kPDGcode==2212){
//  particle is a participant proton
       ptlzem_t.przem[iside]++;
       enzem_t.eprzem[iside]+=energy0;
     } else if(current.kPDGcode==211 || current.kPDGcode==-211){     
//  particle is a participant pion
       ptlzem_t.pizem[iside]++;
       enzem_t.epizem[iside]+=energy0;
     } else if(current.kPDGcode==22){     
//  particle is a gamma
       ptlzem_t.gamzem[iside]++;
       enzem_t.egamzem[iside]+=energy0;
     }
//  define indem from kPDGcode
     Int_t indem=1;
     if(current.kPDGcode==22 || TMath::Abs(current.kPDGcode)==11) indem=0;
     if(indem==0) {
       trl = TrackLen/Chi0ZEM;
       energy = FindInt(energy0,trl);
/*
       printf(" em particle inside ZEM\n");
       printf(" track length in chi0 = %f\n",trl);
       printf(" true energy = %f  -  estimated energy released in ZEM = %f\n",energy0,energy);
*/
//  add experimental fluctuations
       Double_t fluctpc = TMath::Sqrt(res1ZEM*res1ZEM/energy+res2ZEM*res2ZEM);
//       printf(" fluctuation in per cent = %f\n",fluctpc);
       Double_t fluct = fluctpc*energy;
//       printf(" fluctuation in GeV = %f\n",fluct);
       energy = gRandom->Gaus(energy,fluct);
//       printf(" after exper. spread: energy = %f\n",energy);
    } else {
       par[0]=0.02+0.996*energy0;
       par[1]=0.483/(TMath::Log10(energy0)-0.4825);
//       printf(" paramas to model the integral of hsp: p0 = %f - p1 = %f\n",par[0],par[1]);
       trl = TrackLen/LambdaZEM;
       energy = hsp_Int_t(trl,par);

       
/*
       printf(" hadronic particle inside ZEM\n");
       printf(" track length in lambda = %f\n",trl);
       printf(" true energy = %f  -  estimated energy released in ZEM = %f\n",energy0,energy);
*/
//       delete fh;
//       printf(" integrale da TF1 tra 0 e TrackLen = %f\n",energy);
//

//add experim. fluctuation 
       TF1 *resh = new TF1("hfluct","120*TMath::Exp(-0.1*x)+21.*TMath::Exp(-0.013*x)",0.0,350.);
       Double_t r1 = resh->GetRandom(0.,350.);
//       printf(" exper. fluctuation r1 = %f\n",r1);
       Double_t frac = r1/46.7;
       energy *= frac;
//       printf(" after exper. spread: energy = %f\n",energy);
       delete resh;

  }
      enexp_t.ezem[iside] += energy;  
  }  //endif on TrackLen
  px = px_ori;
}


Double_t FindTrkLen(Double_t *Vect, Double_t *h) {
  Double_t p[3],u[3],d[3];
  Double_t pn[3],ratio[3];
  
  if(current.idcalo == 0) {
    p[0] = Vect[0]-geom.xczn[current.iside];
    p[1] = Vect[1]-geom.yczn[current.iside];
    p[2] = -0.50; 
  } else {
    p[0] = Vect[0]-geom.xczp[current.iside];
    p[1] = Vect[1]-geom.yczp[current.iside];
    p[2] = -0.75; 
  }

  for(Int_t i=0; i<3; i++){
    u[i] = Vect[3+i];
  }
/*   
  printf("initial point x y z = %f %f %f\n",p[0],p[1],p[2]);
  printf("initial direction ux uy uz = %f %f %f\n",u[0],u[1],u[2]);
  printf("half dimensions = %f %f %f\n",h[0],h[1],h[2]);
*/
//  find tracklength
  for(Int_t i=0; i<3; i++) {
    d[i] = h[i] - copysign(1.0,u[i])*p[i];
  }
  Double_t dmax = 0.;
  Int_t jmax = -1;
  for(Int_t i=0; i<3; i++){
   if(d[i]>dmax) {
    dmax = d[i];
    jmax = i;
   }
  }
  Double_t trlm = dmax/TMath::Abs(u[jmax]);
/*  
  printf("dx = %f - dy = %f - dz = %f\n",d[0],d[1],d[2]); 
  printf("dmax = %f - jmax = %d\n",dmax,jmax);
  printf("trlm = %f\n",trlm);
*/
  for(Int_t i=0; i<3; i++){
    pn[i] = p[i] + trlm * u[i];
    ratio[i] = TMath::Abs(pn[i])/h[i];
  }  
/*
  printf(" xn =%f - yn = %f - zn = %f\n",pn[0],pn[1],pn[2]);
  printf(" ratio x =%f - ratio y = %f - ratio z = %f\n",ratio[0],ratio[1],ratio[2]);
*/
  Double_t ratmax = 0.;
  Int_t j = 0;
  for(Int_t i=0; i<3; i++){
   if(ratio[i]>ratmax) {
    ratmax = ratio[i];
    j = i;
   }
  }
  d[j] = h[j] - copysign(1.0,u[j])*p[j];
  Double_t trl = d[j]/TMath::Abs(u[j]);
  Int_t ipfin = 2*j;
  if(u[j]>0.) ipfin = ipfin+1;

  if(current.evnt%steer.nevfreq == 0) {
//  printf("ratmax = %f\n",ratmax);
    printf(" in FindTrLen: particle could hit plane = %d - track length in m = %f\n",ipfin,trl);
  }
  return trl;
}

//--------------------------------------------------------------------------------
void phenfZN(Double_t *KinVect, Double_t phepm[], Double_t nfinzn[])
{
//
//  simulation of photoelectrons produced into naked fibres beyond ZN 
//
//  number of photoelectrons produced in the naked fibres beyond ZN 
//  normalized to sumq_av ( = sumqnf/sumq_av)
//  is fitted as a second order polymonial as a function of x (horizontal coord
//  in the ZN reference frame) - from nfull_fromip.root
static const Double_t sumqnfnorm_vs_x[3] = {0.036, -0.0048, 0.0196};  
static const Double_t qcnfnorm_vs_x[3] = {0.070, -0.00093, 0.0051};  
//  the ratio phe(i)/sumqnf for i = 1 and 3 can be fitted with a 
//  third order polynomial as function of x  
//  The best parameters are for PMT1 and for PMT3:
//  (0.28, -0.061, -0.00197, 0.0004)
//  while for PMT2 and PMT4 : 
//  (0.22, 0.039, 0.00197, -0.0004)
static const Double_t coef_znnf_odd[4] = {0.22, 0.039, 0.00197, -0.0004};
static const Double_t coef_znnf_even[4] = {0.28, -0.061, -0.00197, 0.0004};

Double_t q[4];
Double_t x = (KinVect[0]-geom.xczn[current.iside])*100.;
Double_t sumq_av = 0.0;
  for(int i=0; i<5; i++) {
    sumq_av += phepm[i];
    sumq_av *= 0.5;
  }
  Double_t sumqnf = sumqnfnorm_vs_x[0]+sumqnfnorm_vs_x[1]*x+sumqnfnorm_vs_x[2]*x*x;
  sumqnf *= sumq_av;
  for(int i=0; i<4; i++){
    if(i%2 == 0) {
     q[i]=coef_znnf_even[0]+coef_znnf_even[1]*x+coef_znnf_even[2]*x*x+coef_znnf_even[3]*x*x*x;
     q[i] *= sumqnf;
    } else {
     q[i]=coef_znnf_odd[0]+coef_znnf_odd[1]*x+coef_znnf_odd[2]*x*x+coef_znnf_odd[3]*x*x*x;
     q[i] *= sumqnf;
    }
  }
  Double_t qcnf = qcnfnorm_vs_x[0]+qcnfnorm_vs_x[1]*x+qcnfnorm_vs_x[2]*x*x;
  qcnf *= sumq_av;
  for(int i=0; i<4; i++){
    nfinzn[i+1] = q[i];
  }
  nfinzn[0] = qcnf;
  if(current.evnt%steer.nevfreq==0) {
    printf("phe in naked fibres beyond ZN\n");
    for(int i=0; i<5; i++){
      printf("phe in PM[%d] = %f\n",i,nfinzn[i]);
    }
  }
}

//--------------------------------------------------------------------------------
void xtalk_inzpnf(Double_t *KinVect, Double_t phepm[], Double_t xtinzpnf[])
{
//  simulation of photoelectrons produced into naked fibres beyond ZP 

//  number of photoelectrons produced in the naked fibres beyond ZP 
//  normalized to sumq_av ( = sumtnf/sumq_av)
//  is fitted as a second order polymonial as a function of x 
//  (horizontal coord in the ZN reference frame). 
//  from  nfull_fromip.root 
static const Double_t sumtnfnorm_vs_x[3] = {0.013, 0.0059, 0.0034};
//  number of photoelectrons produced in the naked fibres beyond ZP 
//  normalized to sumq_av ( = tcnf/sumq_av)
//  is fitted with atan as a function of x 
//  (horizontal coord in the ZN reference frame). 
static const Double_t tcnfnorm_vs_x[4] = {0.52, 0.32, -7.77, 3.54};
//  Sharing of phes among ZP towers can be fitted 
//  approximately as a straight line
//  t4nfnorm => pol1: (0.29, 0.0012)
//  t3nfnorm => pol1: (0.20, 0.0038)
//  t2nfnorm => pol1: (0.20, -0.0013)
//  t1nfnorm => pol1: (0.29, -0.0013)
static const Double_t coef_zpnf[4][2] = {0.29,-0.0013, 0.20,-0.0013, 0.20,0.0038, 0.29,0.0012};

Double_t q[4];
Double_t x = (KinVect[0]-geom.xczn[current.iside])*100.;
Double_t sumq_av = 0.0;
  for(int i=0; i<5; i++) {
    sumq_av += phepm[i];
    sumq_av *= 0.5;
  }

  Double_t sumtnf = sumtnfnorm_vs_x[0]+sumtnfnorm_vs_x[1]*x+sumtnfnorm_vs_x[2]*x*x;
  sumtnf *= sumq_av;
  Double_t tcnf = tcnfnorm_vs_x[0]+tcnfnorm_vs_x[1]*atan(tcnfnorm_vs_x[2]*(x+tcnfnorm_vs_x[3]));
  tcnf *= sumq_av;
  for(int i=0; i<4; i++){
     q[i]=coef_zpnf[i][0]+coef_zpnf[i][1]*x;
     q[i] *= sumtnf;
  }
  for(int i=0; i<4; i++) {
    xtinzpnf[i+1] = q[i];
  }
  xtinzpnf[0] = tcnf;
  if(current.evnt%steer.nevfreq==0) {
    printf("cross-talk in ZP: phe in naked fibres beyond ZP\n");
    for(int i=0; i<5; i++){
      printf("phe in PM[%d] = %f\n",i,xtinzpnf[i]);
    }
  }

}

//--------------------------------------------------------------------------------
void xtalk_inzp(Double_t *KinVect, Double_t phepm[], Double_t xtinzp[])
{
//  simulation of photoelectrons produced in ZP (fibres inside ZP)
//  (crosstalk) is fitted as an atan function as a function of x
//  TF1 *xtalkonzp = new TF1("xtalkonzp","[0]+[1]*atan([2]*(x+[3]))",-3.5,3.5);
//  parameters of the function:
static const Double_t par_sumtnorm[4] = {0.51, 0.33, 7.14, -3.9};
static const Double_t par_tcnorm[4] = {0.51, 0.32, 7.74, -3.53};
//  Sharing of phes among ZP towers can be fitted as a pol2
//  t4norm => pol2: (0.025, 0.0025, -0.00036)
//  t3norm => pol2: (0.070, -0.0047, -0.0041)
//  t4norm => pol2: (0.20, -0.0073, -0.0023)
//  t1norm => pol2: (0.70, 0.015, 0.0078)
static const Double_t coef_zp[4][3] = {0.70,0.015,0.0078, 0.20,-0.0073,-0.0023, 0.070,-0.0047,-0.0041, 0.025,0.0025,-0.00036};

Double_t q[4];
Double_t x = (KinVect[0]-geom.xczn[current.iside])*100.;
Double_t sumq_av = 0.0;
  for(int i=0; i<5; i++) {
    sumq_av += phepm[i];
    sumq_av *= 0.5;
  }
       Double_t sumtxtalk = par_sumtnorm[0]+par_sumtnorm[1]*atan(par_sumtnorm[2]*(x+par_sumtnorm[3]));
       sumtxtalk *= sumq_av;
       Double_t tcxtalk = par_tcnorm[0]+par_tcnorm[1]*atan(par_tcnorm[2]*(x+par_tcnorm[3]));
       tcxtalk *= sumq_av;
       for(int i=0; i<4; i++){
	  q[i]=coef_zp[i][0]+coef_zp[i][1]*x+coef_zp[i][2]*x*x;
	  q[i] *= sumtxtalk;
       }
  for(int i=0; i<4; i++) {
    xtinzp[i+1] = q[i];
  }
  xtinzp[0] = tcxtalk;
  if(current.evnt%steer.nevfreq==0) {
    printf("cross-talk in ZP: phe inside ZP\n");
    for(int i=0; i<5; i++){
      printf("phe in PM[%d] = %f\n",i,xtinzp[i]);
    }
  }
}

//--------------------------------------------------------------------------------
Bool_t checkZN(Double_t *KinVect) {

  Double_t energy0 = 0.0; // true energy of particle hitting ZN
  Double_t energy = 0.0; // energy of particle after lateral shower leakage
  Double_t RelEneG3 = 0.0; // energy released in ZN if particle interacts in pipe
  Int_t ihadFlag = 1; // ( =1 ==> particle is a hadron)
  Int_t sflFlag = 0;  // ( =1 ==> particle is a secondary particle)
  Double_t eneres1 = 0.;
  Double_t eneres2 = 0.;
  Double_t phepm[5] = {0.,};
  int nphe[5] = {0,};
  Double_t h[3] = {0.,};
  Double_t trklen = 0, trl = 0;

  Double_t nfinzn[5] ={0};
  Double_t xtinzpnf[5] = {0};
  Double_t xtinzp[5] = {0};

  const Double_t LambdaZN = .115; // ZN interaction length in m
  const Double_t Chi0ZN = 0.00398; // ZN radiation length in m
  const Double_t Probh_collinpipe = 0.87; // from nfull_fromip.root
  const Double_t fromREtoEh = 2.08; // 1./0.48 from nfull_fromip.root
  const Double_t Probem_collinpipe = 0.49;
  const Double_t fromREtoEem = 1.2; // 1./0.84 from g0-4000_fromip_8-9.root

  // probability to have phes in naked fibres from nfull_fromip.root
  static const Double_t ProbIntPipe = 0.87; 
  static const Double_t ProbSigqnf = 0.927;
  static const Double_t ProbSigt = 0.974;
  static const Double_t ProbSigtnf = 0.638;

  current.idcalo = 0;
  Double_t xmin =  geom.xczn[current.iside]-geom.hxzn[current.iside]; 
  Double_t xmax =  geom.xczn[current.iside]+geom.hxzn[current.iside];  
  Double_t ymin =  geom.yczn[current.iside]-geom.hyzn[current.iside];  
  Double_t ymax =  geom.yczn[current.iside]+geom.hyzn[current.iside];
  h[0] = geom.hxzn[0];
  h[1] = geom.hyzn[0];
  h[2] = geom.thickzn[0]*0.5;
  

  /*if(current.evnt%steer.nevfreq == 0) {
  printf(" position = %f %f %f\n",KinVect[0],KinVect[1],KinVect[2]);
  printf(" direction = %f %f %f\n",KinVect[3],KinVect[4],KinVect[5]);
  printf(" xmin=%f, xmax=%f, ymin=%f, ymax=%f\n",xmin,xmax,ymin,ymax);
  printf(" half dimensions: hx = %f - hy = %f - hz = %f\n",h[0],h[1],h[2]);
  }*/

  if((KinVect[0]>xmin && KinVect[0]<xmax) && (KinVect[1]>ymin && KinVect[1]<ymax)) {
   //particle inside ZN
   energy0 = KinVect[6];
   energy = energy0;
   enzn_t.etruezn[current.iside] += energy0;
   if(current.evnt%steer.nevfreq == 0) {
     printf("\n  >> particle inside ZN -> ");
     printf(" integrated energy in ZN = %f\n\n",enzn_t.etruezn[current.iside]);
   }
   //fill the ntuple according to type of particle
   if(current.charge==0 && current.kPDGcode==2112) { // neutrons
     if((steer.ifl_bckgrnd == 1) || (steer.ifl_bckgrnd == 3)) {
        Double_t r = gRandom->Uniform(0,1);
        if(r>Probh_collinpipe){
          sflFlag = 1;
          Double_t er = fbckg1hZN->GetRandom();
          RelEneG3 = energy0 * er;
          energy = RelEneG3 * fromREtoEh;
          if(energy>energy0) energy=energy0;
          if(current.evnt%steer.nevfreq == 0) {
            printf(" true energy in ZN when neutron interacts in pipe = %f\n",energy0);
            printf(" probability to interact in pipe for neutrons = %f\n",r);
            printf(" relen/truen in ZN when neutron interacts in pipe = %f\n",er);
            printf(" Released energy (GEANT3) = %f\n",RelEneG3); 
            printf(" Released energy = %f\n",energy); 
          }
        }
      }
      //  fill the structures 
      if(current.partfl){
        //particle is a participant neutron
        ptlzn_t.partnzn[current.iside]++;
        enzn_t.eprnzn[current.iside] += energy0;
      } else {
      //  particle is a spectator neutron 
      ptlzn_t.spectnzn[current.iside]++;
      enzn_t.espnzn[current.iside] += energy0;
      }
      } else if(current.charge==1 && current.kPDGcode==2212) { // protons
      if(current.partfl){
        //particle is a participant proton
        ptlzn_t.partpzn[current.iside]++;
        enzn_t.eprpzn[current.iside] += energy0;     
      } else {
        //  particle is a spectator proton 
        ptlzn_t.spectpzn[current.iside]++;
        enzn_t.esppzn[current.iside] += energy0;
      }
    } else if(current.charge==0 && current.kPDGcode==22) { // gamma
      if(steer.ifl_bckgrnd == 1) {
        Double_t r = gRandom->Uniform(0,1);
        if(r>Probem_collinpipe){
          sflFlag = 1;
          Double_t er = fbckg1emZN->GetRandom();
          RelEneG3 = energy0 * er;
          energy = RelEneG3 * fromREtoEem;
          if(energy > energy0) energy = energy0;
          if(current.evnt%steer.nevfreq == 0) {
            printf(" true energy in ZN when gamma interacts in pipe = %f\n",energy0);
            printf(" probability to interact in pipe for gammas = %f\n",r);
            printf(" relen/truen in ZN when gamma interacts in pipe = %f\n",er);
            printf(" Released energy (GEANT3) = %f\n",RelEneG3); 
            printf(" Estimated released energy = %f\n\n",energy); 
          }
        }
      }
      ptlzn_t.gamzn[current.iside]++;
      enzn_t.egamzn[current.iside] += energy0;
    } else { // anything else
      ptlzn_t.othzn[current.iside]++;
      enzn_t.eothzn[current.iside] += energy0;
    }
    //  find the true centroid of the spot on ZN
    enzn_t.xCentroidzn[current.iside] += (KinVect[0]-geom.xczn[current.iside])*energy0; 
    enzn_t.yCentroidzn[current.iside] += (KinVect[1]-geom.yczn[current.iside])*energy0; 

    // set up code for the shower type
    ihadFlag=1;
    if(current.kPDGcode==22 || current.kPDGcode==11 || current.kPDGcode==-11) ihadFlag=0;

    //  take into account lateral shower leakage
    Double_t distx = KinVect[0]-geom.xczn[current.iside];
    Double_t disty = KinVect[1]-geom.yczn[current.iside];
    Double_t envar = EdgeLoss(0, ihadFlag, &distx, &disty); // ZN
    energy = energy*envar;
    //if(current.evnt%steer.nevfreq == 0 && envar>0.) printf(" after EdgeLoss: energy = %f\n", energy);
    /*if(current.evnt%steer.nevfreq == 0) {
      printf(" in checkZN: ihadFlag = %d\n",ihadFlag);
      printf("\n x = %f m, y = %f m\n",KinVect[0],KinVect[1]);
      printf(" ux = %f, uy = %f\n",KinVect[3],KinVect[4]);
      printf(" true energy = %f\n", KinVect[6]);
      if(sflFlag == 1) {
        printf(" released en. (int. in pipe + shower leakage = %f\n",energy);
      } else {
        printf(" released en. (shower leakage) = %f\n\n",energy);
      }
    }*/

    if(sflFlag == 1){
      KinVect[6] = RelEneG3;  
    } else {
      KinVect[6] = energy;   
    }
    // now add the experimental resolution if required
    if(steer.ifl_res!=0) {
      if(ihadFlag == 1){ 
        eneres1=steer.ZNhadSigmaRes[0];
        eneres2=steer.ZNhadSigmaRes[1];
      }
      else {
        eneres1=steer.ZNemSigmaRes[0];
        eneres2=steer.ZNemSigmaRes[1];
      }
      //  add experimental fluctuations
      Double_t fluctpc = TMath::Sqrt(eneres1*eneres1/energy+eneres2*eneres2);
      Double_t fluct = fluctpc*energy;
      energy = gRandom->Gaus(energy,fluct);
      /*if(current.evnt%steer.nevfreq == 0) {
        //printf(" in checkZN:\n");
        printf("\n true energy from generator = %f\n",energy0);
        printf(" total energy in ZN up to now = %f\n",enzn_t.etruezn[current.iside]);
        printf(" fluctuation in per cent = %f\n",fluctpc);
        printf(" fluctuation in GeV = %f\n",fluct);
        printf(" after exper. spread: energy = %f\n\n",energy);
      }*/
    } 
    enexp_t.ezn[current.iside] += energy;
  
    // find the number of phe in the quadrants
    pheZN(ihadFlag, sflFlag, KinVect, phepm); 
    for(Int_t i=0; i<5; i++) nphe[i] = TMath::Nint(phepm[i]);         
    /*if(current.evnt%steer.nevfreq == 0) {
      printf(" after pheZN: pmc= %f %d \n",phepm[0],nphe[0]);
      printf(" after pheZN: quadrants %f %f %f %f \n",phepm[1],phepm[2],phepm[3],phepm[4]);
      printf(" phe in quadrants = %d %d %d %d \n",nphe[1],nphe[2],nphe[3],nphe[4]);
    }*/

    //  if required find the number of phe produced in the naked fibres
    if(steer.ifl_nf > 0) {
      Double_t prob = gRandom->Uniform(0.,1.);
      /*if(current.evnt%steer.nevfreq == 0) {
        printf(" prob = %f to have interaction in the magpipe\n",prob);
        printf(" ProbIntPipe = %f\n",ProbIntPipe);
      }*/
      if(prob <= ProbIntPipe) {
        prob = gRandom->Uniform(0.,1.);
        /*if(current.evnt%steer.nevfreq == 0) {
          printf(" prob = %f to have phes into naked fibres beyond ZN\n",prob);
          printf(" ProbSigqnf = %f\n",ProbSigqnf);
        }*/
        if(prob <= ProbSigqnf) phenfZN(KinVect,phepm,nfinzn);
        prob = gRandom->Uniform(0.,1.);
        /*if(current.evnt%steer.nevfreq == 0) {
          printf(" prob = %f to have phes into naked fibres beyond ZP\n",prob);
          printf(" ProbSigtnf = %f\n",ProbSigtnf);
        }*/
        if(prob <= ProbSigtnf) xtalk_inzpnf(KinVect, phepm, xtinzpnf);
        prob = gRandom->Uniform(0.,1.);
        /*if(current.evnt%steer.nevfreq == 0) {
          printf(" prob = %f to have phes into ZP (xtalk)\n",prob);
          printf(" ProbSigt = %f\n",ProbSigt);
        }*/
        if(prob <= ProbSigt) xtalk_inzp(KinVect, phepm, xtinzp);
      }
      if(current.evnt%steer.nevfreq==0){
          printf(" energy = %f - x = %f\n", energy0, KinVect[0]);
          /*printf(" qcnf = %f\n", nfinzn[0]);
          printf(" q1nf = %f - q2nf = %f\n", nfinzn[1], nfinzn[2]);
          printf(" q3nf = %f - q4nf = %f\n", nfinzn[3], nfinzn[4]);
          printf(" xttcnf = %f\n", xtinzpnf[0]);
          printf(" t1nf = %f - t2nf = %f\n", xtinzpnf[1], xtinzpnf[2]);
          printf(" t3nf = %f - t4nf = %f\n", xtinzpnf[3], xtinzpnf[4]);
          printf(" tcxtalk = %f\n", xtinzp[0]);
          printf(" t1 = %f - t2 = %f\n", xtinzp[1], xtinzp[2]);
          printf(" t3 = %f - t4 = %f\n", xtinzp[3], xtinzp[4]);*/
      }
    }
    // sumup the photoelectrons for all the particles in this event
    phe_t.q1[current.iside] += nphe[1];        
    phe_t.q2[current.iside] += nphe[2];        
    phe_t.q3[current.iside] += nphe[3];        
    phe_t.q4[current.iside] += nphe[4];        
    phe_t.qc[current.iside] += nphe[0]; 
    for(Int_t i=0; i<5; i++) nphe[i] = TMath::Nint(nfinzn[i]);         
    phenf_t.q1nf[current.iside] += nphe[1];        
    phenf_t.q2nf[current.iside] += nphe[2];        
    phenf_t.q3nf[current.iside] += nphe[3];        
    phenf_t.q4nf[current.iside] += nphe[4];        
    phenf_t.qcnf[current.iside] += nphe[0];        
    for(Int_t i=0; i<5; i++) nphe[i] = TMath::Nint(xtinzpnf[i]);         
    phenf_t.xtt1nf[current.iside] += nphe[1];        
    phenf_t.xtt2nf[current.iside] += nphe[2];        
    phenf_t.xtt3nf[current.iside] += nphe[3];        
    phenf_t.xtt4nf[current.iside] += nphe[4];        
    phenf_t.xttcnf[current.iside] += nphe[0];        
    for(Int_t i=0; i<5; i++) nphe[i] = TMath::Nint(xtinzp[i]);         
    phenf_t.xtt1[current.iside] += nphe[1];        
    phenf_t.xtt2[current.iside] += nphe[2];        
    phenf_t.xtt3[current.iside] += nphe[3];        
    phenf_t.xtt4[current.iside] += nphe[4];        
    phenf_t.xttc[current.iside] += nphe[0];        
    
    return kTRUE;        //endif for particle inside ZN
  } else {
    return kFALSE;
  }
}

//------------------------------------------------------------------------------
Bool_t checkZP( Double_t *KinVect){

  Double_t energy0 = 0.0;   // true energy of particle hitting ZP
  Double_t energy = 0.0;    // energy of particle after lateral shower leakage
  Double_t RelEneG3 = 0.0;  // energy released in ZP if particle interacts in pipe
  Int_t ihadFlag = 1; //( =1 ==> particle is a hadron)
  Int_t sflFlag = 0;  //( =1 ==> particle is a secondary particle)
  Double_t eneres1 = 0.;
  Double_t eneres2 = 0.;
  Double_t phepm[5] = {0.,};
  int nphe[5] = {0,};
  Double_t h[3] = {0.,};

  const Double_t LambdaZP = .184; // ZP interaction length in m
  const Double_t Chi0ZP = 0.015; // ZP radiation length in m
  const Double_t Prob_collinpipe = 0.76; // from p2760_sidea_001-003-004-005.root
  const Double_t fromREtoE = 1.69; // 1./0.593 from same file as above

  current.idcalo = 1;
  h[0] = geom.hxzp[0];
  h[1] = geom.hyzp[0];
  h[2] = geom.thickzp[0]*0.5;
  Double_t xmin =  geom.xczp[current.iside]-geom.hxzp[current.iside]; 
  Double_t xmax =  geom.xczp[current.iside]+geom.hxzp[current.iside];  
  Double_t ymin =  geom.yczp[current.iside]-geom.hyzp[current.iside];  
  Double_t ymax =  geom.yczp[current.iside]+geom.hyzp[current.iside]; 
  
  /*printf(" position = %f %f %f\n",KinVect[0],KinVect[1],KinVect[2]);
  printf(" direction = %f %f %f\n",KinVect[3],KinVect[4],KinVect[5]);
  printf(" xmin=%f, xmax=%f, ymin=%f, ymax=%f\n",xmin,xmax,ymin,ymax);*/
  //printf(" half dimensions: hx = %f - hy = %f - hz = %f\n",h[0],h[1],h[2]);
  
  if((KinVect[0]>xmin && KinVect[0]<xmax) && (KinVect[1]>ymin && KinVect[1]<ymax)) {
     printf("\n  >> particle inside ZP\n");
     energy0 = KinVect[6];
     energy = energy0;
     enzp_t.etruezp[current.iside] += energy0;

     //fill the ntuple according to type of particle
     if(current.charge==0 && current.kPDGcode==2112) {
        if(current.partfl){
          //particle is a participant neutron
          ptlzp_t.partnzp[current.iside]++;
          enzp_t.eprnzp[current.iside]+=energy0;
        } else {
          //  particle is a spectator neutron 
          ptlzp_t.spectnzp[current.iside]++;
          enzp_t.espnzp[current.iside]+=energy0;
        }
     } else if(current.charge==1 && current.kPDGcode==2212) {
        if((steer.ifl_bckgrnd == 1) || (steer.ifl_bckgrnd == 3)) {
          Double_t r = gRandom->Uniform(0,1);
          if(r>Prob_collinpipe){
            sflFlag = 1;
            Double_t er = fbckg1ZP->GetRandom();
            RelEneG3 = energy0 * er;
            energy = RelEneG3 * fromREtoE;
            if(energy>energy0) energy=energy0;
            if(current.evnt%steer.nevfreq == 0) {
              printf(" true energy in ZP when proton interacts in pipe = %f\n",energy0);
              printf(" probability to interact in pipe for protons = %f\n",r);
              printf(" relen/truen in ZP when proton interacts in pipe = %f\n",er);       	                 printf(" Released energy (GEANT3) = %f\n",RelEneG3); 
              printf(" Released energy = %f\n",energy); 
            }
          }
        }
        if(current.partfl){
          //particle is a participant proton
          ptlzp_t.partpzp[current.iside]++;
          enzp_t.eprpzp[current.iside]+=energy0;
        } else {
          //  particle is a spectator proton 
          ptlzp_t.spectpzp[current.iside]++;
          enzp_t.esppzp[current.iside]+=energy0;
        }
      } else if(current.charge==0 && current.kPDGcode==22) {
        // particle is a gamma
        ptlzp_t.gamzp[current.iside]++;
        enzp_t.egamzp[current.iside]+=energy0;
      } else if(current.charge>0 && current.kPDGcode==211) {
          // particle is a piplus
          ptlzp_t.piplzp[current.iside]++;
          enzp_t.epiplzp[current.iside]+=energy0;
      } else {
        // particle is any other particle
        ptlzp_t.othzp[current.iside]++;
        enzp_t.eothzp[current.iside]+=energy0;
      }
      // set up code for the shower type
      ihadFlag=1;
      if(current.kPDGcode==22 || current.kPDGcode==11 || current.kPDGcode==-11) ihadFlag=0;

       //  find the true centroid of the particles spot on ZP
       enzp_t.xCentroidzp[current.iside] += (KinVect[0]-geom.xczp[current.iside])*energy0; 
       enzp_t.yCentroidzp[current.iside] += (KinVect[1]-geom.yczp[current.iside])*energy0; 

       //  take into account lateral shower leakage
       Double_t distx = KinVect[0]-geom.xczp[current.iside];
       Double_t disty = KinVect[1]-geom.yczp[current.iside];
       Double_t envar = EdgeLoss(1, ihadFlag, &distx, &disty);
       energy=energy*envar;
       if(current.evnt%steer.nevfreq == 0) printf(" after EdgeLoss: energy = %f\n",energy);
              
       if(current.evnt%steer.nevfreq == 0) {
         printf(" in checkZP: ihadFlag = %d\n",ihadFlag);
         printf(" true energy from generator = %f\n",KinVect[6]);
         if(sflFlag == 1) {
	         printf(" released en. (int. in pipe + shower leakage = %f\n",energy);
	       } else {
	         printf(" released en. (shower leakage) = %f\n",energy);
	       }
       }

       if(sflFlag == 1){
         KinVect[6] = RelEneG3;  
       } else {
         KinVect[6] = energy;   
       }

      // now add the experimental resolution if required
     if(steer.ifl_res!=0) {
       if(ihadFlag == 1){ 
         eneres1=steer.ZPhadSigmaRes[0];
         eneres2=steer.ZPhadSigmaRes[1];
       }
       else {
         eneres1=steer.ZPemSigmaRes[0];
         eneres2=steer.ZPemSigmaRes[1];
       }
       //  add experimental fluctuations
       Double_t fluctpc = TMath::Sqrt(eneres1*eneres1/energy+eneres2*eneres2);
       Double_t fluct = fluctpc*energy;
       energy = gRandom->Gaus(energy,fluct);
       if(current.evnt%steer.nevfreq == 0) {
         printf(" in checkZP:\n");
         printf(" true energy from generator = %f\n",energy0);
	       printf(" integrated energy in ZP = %f\n",enzp_t.etruezp[current.iside]);
         printf(" released energy in ZP = %f\n",energy);
         printf(" fluctuation in per cent = %f\n",fluctpc);
         printf(" fluctuation in GeV = %f\n",fluct);
         printf(" after exper. spread: energy = %f\n",energy);
       }
     } 
     enexp_t.ezp[current.iside] += energy;
     
     // find the number of phe in the quadrants
     pheZP(ihadFlag,sflFlag,KinVect,phepm); 
     for(Int_t i=0; i<5; i++) nphe[i] = TMath::Nint(phepm[i]);         
     //  sumup the photoelectrons for all the particles in this event
     phe_t.t1[current.iside] += nphe[1];        
     phe_t.t2[current.iside] += nphe[2];        
     phe_t.t3[current.iside] += nphe[3];        
     phe_t.t4[current.iside] += nphe[4];        
     phe_t.tc[current.iside] += nphe[0];
     /*if(current.evnt%steer.nevfreq == 0) {
       printf(" after pheZP: pmc= %f %d\n",phepm[0],nphe[0]);
       printf(" after pheZP: torri %f %f %f %f \n",phepm[1],phepm[2],phepm[3],phepm[4]);        
       printf(" nphe: torri %d %d %d %d \n",nphe[1],nphe[2],nphe[3],nphe[4]);
       printf(" t1 = %d\n",phe_t.t1[current.iside]);
       printf(" t2 = %d\n",phe_t.t2[current.iside]);
       printf(" t3 = %d\n",phe_t.t3[current.iside]);
       printf(" t4 = %d\n",phe_t.t4[current.iside]);
     }*/        
     return kTRUE;  //endif for particle inside ZP      
  } else {
     return kFALSE;        
  } 
}

//_____________________________________________________________________________
void FindCentroid(Int_t is, bool isFragment, int A) {

    static const Double_t xcn[4] = {-1.76, 1.76, -1.76, 1.76};
    static const Double_t ycn[4] = {-1.76, -1.76, 1.76, 1.76};
    static const Double_t xct[4] = {-8.4, -2.8, 2.8, 8.4};

    Double_t q[4],w[4];
    Double_t x = 0., y = 0.;
    Double_t sumw = 0.;
    Double_t sumq = 0.;

    //  two methods are implemented:
    //  if the equivalent number of neutrons is greater than neqlimit,
    //  the standard method (see Gemme thesis) is taken,
    //  otherwise the correlations are used 
    const Int_t neqlimit = 10;

    //  constants to be used in the standard centroid reconstruction
    const Double_t alpha = 0.395;
    const Double_t centr_coeff[3] = {1.894, -0.7126, 0.7179};

    // if equivalent number of spectator neutron is less than neqlimit
    // ==> tangent function with four parameters
    // taken from simulated data 
    Double_t pcorr[3] = {-0.256,0.115,0.368};

    //  calculate the coordinates of the true spectator centroid 
    //  for both arms
    if(enzn_t.etruezn[is]>0.0) {
      enzn_t.xCentroidzn[is] = enzn_t.xCentroidzn[is]/enzn_t.etruezn[is];
      enzn_t.yCentroidzn[is] = enzn_t.yCentroidzn[is]/enzn_t.etruezn[is];
    } else {
      enzn_t.xCentroidzn[is] = 9999.0;
      enzn_t.yCentroidzn[is] = 9999.0;
    }
    if(enzp_t.etruezp[is]>0.0) {
      enzp_t.xCentroidzp[is] = enzp_t.xCentroidzp[is]/enzp_t.etruezp[is];
      enzp_t.yCentroidzp[is] = enzp_t.yCentroidzp[is]/enzp_t.etruezp[is];
    } else {
      enzp_t.xCentroidzp[is] = 9999.0;
      enzp_t.yCentroidzp[is] = 9999.0;
    }

    //  calculate experimental centroid starting from the number of phe
    //  on the four quadrants
    //  ----------   ZN ------------
    q[0] = phe_t.q1[is];
    q[1] = phe_t.q2[is];
    q[2] = phe_t.q3[is];
    q[3] = phe_t.q4[is]; 
    sumq = 0;
    sumw = 0;
    for(int i=0; i<4; i++){
      w[i] = TMath::Power(q[i],alpha); 
      sumw += w[i];
      sumq += q[i];
    }

    //  event cannot be analyzed: sumq == 0!
    if(sumq == 0) {
       enexp_t.xreczn[is]=9999.0;
       enexp_t.yreczn[is]=9999.0;
    } else {
    
    //  find the equivalent number of neutrons hitting the ZN calorimeter
    double epern = steer.ebpern; //  modified by chiara (to account for energy x nucleon)
    if(isFragment) epern = steer.ebpern/A;
    Double_t equiv_n = (enzn_t.espnzn[is]+enzn_t.eprnzn[is])/epern;
    Int_t neq = TMath::Nint(equiv_n);
    Double_t coeff = centr_coeff[0]+centr_coeff[1]/(equiv_n+centr_coeff[2]);

    //  standard centroid reconstruction 
    if(neq > neqlimit) {
      x = 0;
      y = 0;
      for(int i=0; i<4; i++) {
        x += xcn[i] * w[i];
        y += ycn[i] * w[i];
      }
      x = coeff*x/sumw; 
      y = coeff*y/sumw; 
      x = x + geom.xczn[is];
      y = y + geom.yczn[is];
      if(current.evnt%steer.nevfreq==0){
        //printf("xc1 = %f - xc2 = %f - xc3 = %f - xc4 = %f\n",xcn[0],xcn[1],xcn[2],xcn[3]);
        //printf("yc1 = %f - yc2 = %f - yc3 = %f - yc4 = %f\n",ycn[0],ycn[1],ycn[2],ycn[3]);
        //printf("equiv_n = %f  -  coeff = %f  -  sumw = %f\n",equiv_n,coeff,sumw);
        printf(" \n \t ZN centroid: x = %f cm   y= %f cm  \n", x, y);
      }

      //  simple reconstruction for a limited number of n
    } else {
      Double_t q1q2 = q[0]/sumq+q[1]/sumq;
      Double_t q1q3 = q[0]/sumq+q[2]/sumq;
      y = TMath::Tan((q1q2-hpar_q1q2[0])/hpar_q1q2[1])/hpar_q1q2[2]-hpar_q1q2[3];
      x = TMath::Tan((q1q3-hpar_q1q3[0])/hpar_q1q3[1])/hpar_q1q3[2]-hpar_q1q3[3];
      //  if neq > 1 apply some minor correction 
      if(neq>1) {
        Double_t correction = 0;
        Double_t temp = 0;
	      temp = (pcorr[2]+x*x)*(pcorr[2]+x*x);
        correction = pcorr[0]*x + pcorr[1]*x/temp;
        x += correction;
        temp = (pcorr[2]+y*y)*(pcorr[2]+y*y);
        correction = pcorr[0]*x + pcorr[1]*y/temp;
        y += correction;
     }      
    }
    enexp_t.xreczn[is] = x*0.01+geom.xczn[is];
    enexp_t.yreczn[is] = y*0.01+geom.yczn[is];
    }

    sumq = 0;
    sumw = 0;
//  ----------   ZP ------------
      q[0] = phe_t.t1[is];
      q[1] = phe_t.t2[is];
      q[2] = phe_t.t3[is];
      q[3] = phe_t.t4[is];
    
    Double_t qmax = 0;
    Int_t imax = -1;
    for(int i=0; i<4; i++){
      if(q[i]>qmax) {
        qmax = q[i];
	      imax = i;
      }
      sumq += q[i]; 
    }

    Double_t xr = 9999.0;
    Double_t t = 0;
    Double_t hpart[4];
    if(sumq>0.) {
      if(imax == 0) {
        t=q[0]/sumq;
        for(int i=0; i<4; i++) hpart[i] = hpar_t1[i];
      } else if(imax == 1) {
        t=(q[0]+q[1])/sumq;
        for(int i=0; i<4; i++) hpart[i] = hpar_t1t2[i];
      } else if(imax > 1) {
        t=(q[0]+q[1]+q[2])/sumq;
        for(int i=0; i<4; i++) hpart[i] = hpar_t1t2t3[i];
      }
      xr = (TMath::Tan((t-hpart[0])/hpart[1])/hpart[2]-hpart[3])*0.01;
    }
    //    enexp_t.xreczp[is]=xr+geom.xczp[is];
    enexp_t.xreczp[is] = xr;


    /*if(current.evnt%steer.nevfreq==0){
      printf(" ZP centroid:\n");
      for(int i=0; i<4; i++) printf(" t[%d] = %f\n",i,q[i]);
      printf(" tmax = t[%d] = %f\n",imax,qmax);
      printf(" sumq = %f\n",sumq);
      printf(" t = %f\n",t);
      for(int i=0; i<4; i++) printf(" hpart[%d] = %f\n",i,hpart[i]);
      printf(" xr = %f\n",xr);
    }*/

    /*if(current.evnt%steer.nevfreq==0){
      printf(" iside = %d\n",is);
      printf("\n x coordinate of centroid on ZN = %f\n",enzn_t.xCentroidzn[is]);
      printf(" y coordinate of centroid on ZN = %f\n",enzn_t.yCentroidzn[is]);
      //printf(" x coordinate of centroid on ZP = %f\n",enzp_t.xCentroidzp[is]);
      //printf(" y coordinate of centroid on ZP = %f\n",enzp_t.yCentroidzp[is]);
      printf(" rec. x coordinate of centroid on ZN = %f\n",enexp_t.xreczn[is]);
      printf(" rec. y coordinate of centroid on ZN = %f\n",enexp_t.yreczn[is]);
      //printf(" rec. x coordinate of centroid on ZP = %f\n\n",enexp_t.xreczp[is]);
    }*/
}

//_____________________________________________________________________________
void SwapTowers() {
// code to take into account the experimental layout

   Int_t swapq;

// for ZN in sideA swap Q1 with Q2 and swap Q3 with Q4
    swapq = phe_t.q2[0];
    phe_t.q2[0] = phe_t.q1[0];
    phe_t.q1[0] = swapq;
    swapq = phe_t.q4[0];
    phe_t.q4[0] = phe_t.q3[0];
    phe_t.q3[0] = swapq;
    //printf("swap ZN towers sideA (fibers inside calorimeter\n");
    //printf("q1 = %d, q2 = %d, q3 = %d, q4 = %d\n",phe_t.q1[0],phe_t.q2[0],phe_t.q3[0],phe_t.q4[0]);

    Int_t q[4];
    q[0] = phenf_t.q1nf[0];
    q[1] = phenf_t.q2nf[0];
    q[2] = phenf_t.q3nf[0];
    q[3] = phenf_t.q4nf[0];
    phenf_t.q2nf[0] = q[0];
    phenf_t.q1nf[0] = q[1];
    phenf_t.q4nf[0] = q[2];
    phenf_t.q3nf[0] = q[3];
    //printf("swap ZN towers sideA (naked fibers beyond ZN calorimeter\n");
    //printf("q1 = %d, q2 = %d, q3 = %d, q4 = %d\n",phenf_t.q1nf[0],phenf_t.q2nf[0],phenf_t.q3nf[0],phenf_t.q4nf[0]);
    
    q[0] = phenf_t.xtt1nf[0];
    q[1] = phenf_t.xtt2nf[0];
    q[2] = phenf_t.xtt3nf[0];
    q[3] = phenf_t.xtt4nf[0];
    phenf_t.xtt4nf[0] = q[0];
    phenf_t.xtt3nf[0] = q[1];
    phenf_t.xtt2nf[0] = q[2];
    phenf_t.xtt1nf[0] = q[3];
    //printf("cross-talk signals\n");
    //printf("swap ZP towers sideA (naked fibers beyond ZP calorimeter\n");
    //printf("t1 = %d, t2 = %d, t3 = %d, t4 = %d\n",phenf_t.xtt1nf[0],phenf_t.xtt2nf[0],phenf_t.xtt3nf[0],phenf_t.xtt4nf[0]);
    
    q[0] = phenf_t.xtt1[0];
    q[1] = phenf_t.xtt2[0];
    q[2] = phenf_t.xtt3[0];
    q[3] = phenf_t.xtt4[0];
    phenf_t.xtt4[0] = q[0];
    phenf_t.xtt3[0] = q[1];
    phenf_t.xtt2[0] = q[2];
    phenf_t.xtt1[0] = q[3];
    //printf("cross-talk signals\n");
    //printf("swap ZP towers sideA (fibers inside ZP calorimeter\n");
    //printf("t1 = %d, t2 = %d, t3 = %d, t4 = %d\n",phenf_t.xtt1[0],phenf_t.xtt2[0],phenf_t.xtt3[0],phenf_t.xtt4[0]);

// for ZP in sideA : T1->T4, T2->T3, T3->T2, T4->T1
    q[0] = phe_t.t1[0];
    q[1] = phe_t.t2[0];
    q[2] = phe_t.t3[0];
    q[3] = phe_t.t4[0];
    phe_t.t4[0] = q[0];
    phe_t.t3[0] = q[1];
    phe_t.t2[0] = q[2];
    phe_t.t1[0] = q[3];
    //printf("swap ZP towers sideA (fibers inside calorimeter\n");
    //printf("t1 = %d, t2 = %d, t3 = %d, t4 = %d\n",phe_t.t1[0],phe_t.t2[0],phe_t.t3[0],phe_t.t4[0]);

}

//_____________________________________________________________________________
void FindFlowQ(Int_t is) {
const Double_t phiq[4] = {3.926991, 5.497787, 2.356194, 0.785398};
Double_t q[4];

q[0] = phe_t.q1[is];
q[1] = phe_t.q2[is];
q[2] = phe_t.q3[is];
q[3] = phe_t.q4[is];
Double_t qx = 0;
Double_t qy = 0;
Double_t sumq = 0;
for (int i=0; i<4; i++){
  qx += cos(phiq[i])*q[i];
  qy += sin(phiq[i])*q[i];
  sumq += q[i];
}
if(sumq >0) {
  flowvar_t.Qx[is]  = qx/sumq;
  flowvar_t.Qy[is]  = qy/sumq;
} else {
  flowvar_t.Qx[is] = 9999.; 
  flowvar_t.Qy[is] = 9999.; 
}
    /*if(current.evnt%steer.nevfreq==0){
      printf(" iside = %d\n",is);
      printf(" phe on quadrants: %f %f %f %f\n",q[0],q[1],q[2],q[3]);
      printf(" sum of quadrants: %f\n",sumq);
      printf(" Qx = %f  -  Qy = %f\n",flowvar_t.Qx[is],flowvar_t.Qy[is]);
    }*/
}

//_____________________________________________________________________________
   Double_t gausvar(Double_t xx, Double_t par_sig[])
   {
//      Double_t xx =x[0];
      Double_t den = par_sig[2]+par_sig[3]*(xx-par_sig[1])/par_sig[1];
      Double_t f = par_sig[0]*exp(-0.5*(xx-par_sig[1])*(xx-par_sig[1])/(den*den));
      return f;
   }

//_____________________________________________________________________________
   void GetSample(Int_t is,Int_t kcal) 
   {
//   static const Double_t MeanTOF = -0.33;
   static const Double_t sigma1 = 2.9;
//   static const Double_t sigma2 = 0.14;
   static const Double_t Gainpp = 4.67e05;
   static const Double_t Gainpbpb = 4.67e03;
//   static const Double_t GainZEM = 1.0e04;
   static const Double_t q_ele = 1.6e-19;
   static const Double_t deltat = 18.0e-09;
   static const Double_t fromQ_toV[2] = {-1.23, 5.63};
   static const Double_t fromV_tomeanTOF[2] = {-1.70, -0.0031};
   static const Double_t frommeanTOF_tosigma2 = 0.247;
   static const Double_t fromV_toch = 3.0;
   Double_t GainZN;
   Double_t GainZP;
   Double_t ampl[5];
   Double_t t_spread;
   Double_t parsig[4];

   if(steer.idgen==3) {
     GainZN = Gainpp;
     GainZP = Gainpp;
   } else {
     GainZN = Gainpbpb;
     GainZP = Gainpbpb;
   }
   Double_t sum = 0;
   Double_t minampl = 0;
   /*if(current.evnt%steer.nevfreq==0){
     printf("in GetSample - iside = %d  - kcal = %d\n",is,kcal);
     if(kcal==1 || kcal==3) printf("phe: qc=%d, q1=%d, q2=%d, q3=%d, q4=%d\n",phe_t.qc[is],phe_t.q1[is],phe_t.q2[is],phe_t.q3[is],phe_t.q4[is]);
     if(kcal==2 || kcal==3) printf("phe: tc=%d, t1=%d, t2=%d, t3=%d, t4=%d\n",phe_t.tc[is],phe_t.t1[is],phe_t.t2[is],phe_t.t3[is],phe_t.t4[is]);
   }*/
// get sample for ZN
   if(kcal==1 || kcal==3){
   if(steer.ifl_newrdout>0) {
     ampl[0] = -phe_t.qc[is]*q_ele*GainZN*0.1e6/deltat;
     ampl[1] = -phe_t.q1[is]*q_ele*GainZN*0.1e6/deltat;   
     ampl[2] = -phe_t.q2[is]*q_ele*GainZN*0.1e6/deltat;   
     ampl[3] = -phe_t.q3[is]*q_ele*GainZN*0.1e6/deltat;   
     ampl[4] = -phe_t.q4[is]*q_ele*GainZN*0.1e6/deltat;   
     
     Double_t MeanTOF = fromV_tomeanTOF[0] + fromV_tomeanTOF[1]*ampl[0];
     Double_t sigma2 = frommeanTOF_tosigma2*MeanTOF;
     for(Int_t i=0; i<5; i++){
       parsig[0] = ampl[i];
       parsig[1] = MeanTOF;
       parsig[2] = sigma1;
       parsig[3] = sigma2;
       /*if(current.evnt%steer.nevfreq==0) {
         printf("i = %d - params = %f %f %f %f\n",i,parsig[0],parsig[1],parsig[2],parsig[3]);
       }*/
       
//  choose time spread: gaussian distribution with a sigma = steer.SigmaTOF around MeanTOF
     t_spread = gRandom->Gaus(0.,steer.SigmaTOF);
     for(Int_t k=0; k<24; k++){
       Double_t x = -30.+2.0*k+t_spread;
       Double_t c = gausvar(x, parsig);
       raw_t.zn[k][i][is]=c*fromV_toch;
       //if(current.evnt%steer.nevfreq==0) printf("k = %d  -  x = %f  -  y = %f - channel = %f\n",k,x,c,raw_t.zn[k][i][is]);
       if((i==0)&&(k>14)&&(k<20)) {       
         sum += c;
         if(c<minampl) {
           minampl = c;
	         raw_t.Time_ZN[is] = k;
         }
       }
     }
   }
   raw_t.Ampl_ZN[is] = ampl[0];
   raw_t.Charge_ZN[is] = sum*20.;
   raw_t.SigmaTime_ZN[is] = t_spread;
   }  //endif over ifl_newrdout>0
   if(TMath::Abs(steer.ifl_newrdout)==2) {
     for(Int_t i=0; i<5; i++){
       for(Int_t k=0; k<24; k++){
         Double_t blsprd = gRandom->Gaus(steer.BaseLineMean,steer.BaseLineSpread);
         raw_t.zn[k][i][is] += blsprd;
         /*if(current.evnt%steer.nevfreq==0) {
            printf(" pmt = %d - sampl no. %d  base line spread = %f\n",i,k,blsprd);
	          printf(" sample k = %d:  sample = %f\n",k,raw_t.zn[k][i][is]);
	       }*/
       }
     }
   }
   /*if(current.evnt%steer.nevfreq==0){
     printf("charge of ZN signal (only PMC) = %f pC\n",raw_t.Charge_ZN[is]);
     printf("time of ZN signal (only PMC) = %f\n",raw_t.Time_ZN[is]);
     printf("sigma time of ZN signal (only PMC) wrt sim = %f\n",raw_t.SigmaTime_ZN[is]);
   }*/
   }

// get sample for ZP
   if(steer.ifl_newrdout>0) {
   sum = 0;
   minampl = 0;
   if(kcal==2 || kcal==3){
     ampl[0] = phe_t.qc[is]*q_ele*GainZN*100./deltat;
     raw_t.Ampl_ZP[is] = -ampl[0];
     ampl[1] = phe_t.q1[is]*q_ele*GainZN*100./deltat;   
     ampl[2] = phe_t.q2[is]*q_ele*GainZN*100./deltat;   
     ampl[3] = phe_t.q3[is]*q_ele*GainZN*100./deltat;   
     ampl[4] = phe_t.q4[is]*q_ele*GainZN*100./deltat;   
     for(Int_t i=0; i<5; i++){
     //if(current.evnt%steer.nevfreq==0) printf("i = %d  -  amplitude = %lf\n",i,ampl[i]);
//  choose time spread: gaussian distribution with a sigma = steer.SigmaTOF around MeanTOF
     t_spread = gRandom->Gaus(0.,steer.SigmaTOF);
     for(Int_t k=0; k<24; k++){
       Double_t x = -30.+2.0*k+t_spread;
       Double_t c = gausvar(x, parsig);
       raw_t.zp[k][i][is]=c*fromV_toch;
       //if(current.evnt%steer.nevfreq==0) printf("k = %d  -  x = %f  -  y = %f\n",k,x,c);
       if((i==0)&&(k>14)&&(k<20)) {       
         sum += c;
         if(c<minampl) {
           minampl = c;
	   raw_t.Time_ZP[is] = x;
         }
       }
     }
   }
   raw_t.Charge_ZP[is] = sum*20.;
   raw_t.SigmaTime_ZP[is] = t_spread;
   } //endif over ifl_newrdout>0
   if(TMath::Abs(steer.ifl_newrdout)==2) {
     for(Int_t i=0; i<5; i++){
       for(Int_t k=0; k<24; k++){
         Double_t blsprd = gRandom->Gaus(steer.BaseLineMean,steer.BaseLineSpread);
         //if(current.evnt%steer.nevfreq==0) printf(" pmt = %d:  base line spread = %f\n",i,blsprd);
         raw_t.zp[k][i][is] += blsprd;
         //if(current.evnt%steer.nevfreq==0) printf(" sample k = %d:  sample = %f\n",k,raw_t.zp[k][i][is]);
       }
     }
   }
   /*if(current.evnt%steer.nevfreq==0){
     printf("charge of ZP signal (only PMC) = %f pC\n",raw_t.Charge_ZP[is]);
     printf("time of ZP signal (only PMC) = %f\n",raw_t.Time_ZP[is]);
     printf("sigma time of ZP signal (only PMC) wrt sim = %f\n",raw_t.SigmaTime_ZP[is]);
   }*/
   }

/*
// get sample for ZEM
   sum = 0;
   minampl = 0;
   ampl = phe_t.tc[is]*q_ele*GainZEM*100./deltat; ???
   raw_t.Ampl_ZEM[is] = ampl;
   f->SetParameter(0,ampl);
   if(current.evnt%steer.nevfreq==0) printf("amplitude = %f\n",ampl);
   for(Int_t k=0; k<24; k++){
       Double_t x = -7.+k;
       Double_t c = f->Eval(x,0.,0.,0.);
       raw_t.zem[k][is]=c;
       if(current.evnt%steer.nevfreq==0) printf("k = %d  -  x = %f  -  y = %f\n",k,x,c);
       sum += c;
       if(c<minampl) {
           minampl = c;
	   raw_t.Time_ZEM[is] = x;
       }
   }
   raw_t.Charge_ZEM[is] = sum;
   if(current.evnt%steer.nevfreq==0){
     printf("charge of ZEM signal = %f\n",sum);
     printf("time of ZEM signal = %f\n",raw_t.Time_ZEM[is]);
   }
*/
//   delete f;
//   delete gr;
   }

//------------------------------------------------------------------------------------------
void rawSignals(Int_t is) {
//  if required, prepare for signal samples 
  Int_t ical[2] = {0,0};

  if(phe_t.qc[is] > 0.) {
    ical[is] = 1;
    if(phe_t.tc[is] > 0.) ical[is] = 3;
  }
  else {
    ical[is] = 0;
    if(phe_t.tc[is] > 0.) ical[is] = 2;
  }
// find out the PMT signal samples 
   /*if(current.evnt%steer.nevfreq==0){
    printf(" before GetSample: iside = %d  -  ical = %d\n",is,ical[is]);
    if(phe_t.qc[is] > 0.) {
      printf(" signal on ZN\n");
      printf(" phe on PMT: %d %d %d %d %d\n",phe_t.qc[is],phe_t.q1[is],phe_t.q2[is],phe_t.q3[is],phe_t.q4[is]);}
    if(phe_t.tc[is] > 0.) {
      printf(" signal on ZP\n");
      printf(" phe on PMT: %d %d %d %d %d\n",phe_t.tc[is],phe_t.t1[is],phe_t.t2[is],phe_t.t3[is],phe_t.t4[is]);}
   }*/
   Int_t kcal = ical[is];
   if(kcal >0 ) GetSample(is,kcal);
  }

//----------------------------------------------------------------------------
Int_t main(){
  //----------------------------------------------------------------------------
  // Be careful: the fast simulation program has the ZP calorimeters positioned 
  // towards positive x values 
  // while, at the contrary, in the fortran slow sim the ZP is positioned
  // towards negative x values
  // This means that the correlations of ZP variables as functions of ZN 
  // coordinates have to be appropriately corrected
  //----------------------------------------------------------------------------

  OpticEle *oe;
  TVectorT<Double_t> *xcoor = new TVectorT<Double_t>(2);
  TVectorT<Double_t> *ycoor = new TVectorT<Double_t>(2);

  Int_t iev = 0, ip = 0;
  Double_t mass = 0., protonmass = 0., neutronmass = 0.;
  Double_t pLab[4] = {0.,}, fP[4] = {0.,};
  Double_t pmq = 0.;
  Double_t ddp[3] = {0.,}, dddp[3] = {0.,}, dddp0 ;
  Double_t KinVect[7] = {0.,};
  Int_t lost_ptl[20] = {0,};
  Bool_t lostflg = kFALSE;
  Bool_t insideZN = kFALSE;
  Bool_t insideZP = kFALSE;
  char filename[80];
  TStopwatch t;

  t.Start();
  //gRandom = new TRandom3();

  // variables to contain histograms used in the background code (iflbckg = 2)
  TFile *fbckg;
  TH2F *h6051; // nspect probability to give a signal in had. calorimeters
  TH2F *h6053; // pspect probability to give a signal in had. calorimeters
  TH2F *h6055; // ch. part. probability to give a signal in had. calorimeters
  TH2F *h6057; // gamma probability to give a signal in had. calorimeters
  TH2F *h7051; // nspect phe/energy in ZN
  TH2F *h7053; // pspect phe/energy in ZN
  TH2F *h7055; // ch. particle phe/energy in ZN
  TH2F *h7057; // gamma phe/energy in ZN
  TH2F *h7052; // nspect phe/energy in ZP
  TH2F *h7054; // pspect phe/energy in ZP
  TH2F *h7056; // ch. particle phe/energy in ZP
  TH2F *h7058; // gamma phe/energy in ZP
  //same params for n and gamma
  Double_t fnbckgzn[4] = {0.50, 0.20, -0.60, 0.3}; 
  Double_t fnbckgzp0[4] = {0.112, 0.120, 0.334, 0.428};
  Double_t fnbckgzp1[4] = {-0.192e-02, -0.736e-03, 0.341e-02, -0.720e-03};

  // reading steering cards
  rdcards();

  // define branches of the output tree
  strcpy(filename,steer.OutTree_Filename);
  TFile *fot = new TFile(filename,"RECREATE");
  TTree *zdct = new TTree("zdct","Tree from fast MC");
  if(TMath::Abs(steer.idgen)!=3) zdct->Branch("gene",&gene_t,"idgene/I:nucparp/I:nucpart/I:prod_ptl/I:cons_ptl/I:bimp/D:psi_react_plane/D:nf[2]/I:pf[2]/I:vertex[3]/D");
  zdct->Branch("enzn",&enzn_t,"espnzn[2]/D:eprnzn[2]/D:esppzn[2]/D:eprpzn[2]/D:espfrzn[2]/D:egamzn[2]/D:eothzn[2]/D:etruezn[2]/D:xCentroidzn[2]/D:yCentroidzn[2]/D");
  zdct->Branch("ptlzn",&ptlzn_t,"spectnzn[2]/I:partnzn[2]/I:spectpzn[2]/I:partpzn[2]/I:fragzn[2]/I:gamzn[2]/I:othzn[2]/I");
  zdct->Branch("enzp",&enzp_t,"espnzp[2]/D:eprnzp[2]/D:esppzp[2]/D:eprpzp[2]/D:epiplzp[2]/D:espfrzp[2]/D:egamzp[2]/D:eothzp[2]/D:etruezp[2]/D:xCentroidzp[2]/D:yCentroidzp[2]/D");
  zdct->Branch("ptlzp",&ptlzp_t,"spectnzp[2]/I:partnzp[2]/I:spectpzp[2]/I:partpzp[2]/I:piplzp[2]/I:fragzp[2]/I:gamzp[2]/I:othzp[2]/I");
  if(TMath::Abs(steer.idgen)!=3) zdct->Branch("enzem",&enzem_t,"egamzem[2]/D:epizem[2]/D:eprzem[2]/D:eneuzem[2]/D");
  if(TMath::Abs(steer.idgen)!=3) zdct->Branch("ptlzem",&ptlzem_t,"gamzem[2]/I:pizem[2]/I:przem[2]/I:neuzem[2]/I"); 
  zdct->Branch("enexp",&enexp_t,"ezn[2]/D:ezp[2]/D:ezem[2]/D:xreczn[2]/D:yreczn[2]/D:xreczp[2]/D");
  zdct->Branch("phe",&phe_t,"q1[2]/I:q2[2]/I:q3[2]/I:q4[2]/I:qc[2]/I:t1[2]/I:t2[2]/I:t3[2]/I:t4[2]/I:tc[2]/I");
  if(TMath::Abs(steer.idgen)!=3) zdct->Branch("phenf",&phenf_t,"q1nf[2]/I:q2nf[2]/I:q3nf[2]/I:q4nf[2]/I:qcnf[2]/I:t1nf[2]/I:t2nf[2]/I:t3nf[2]/I:t4nf[2]/I:tcnf[2]/I:xtq1[2]/I:xtq2[2]/I:xtq3[2]/I:xtq4[2]/I:xtqc[2]/I:xtq1nf[2]/I:xtq2nf[2]/I:xtq3nf[2]/I:xtq4nf[2]/I:xtqcnf[2]/I:xtt1[2]/I:xtt2[2]/I:xtt3[2]/I:xtt4[2]/I:xttc[2]/I:xtt1nf[2]/I:xtt2nf[2]/I:xtt3nf[2]/I:xtt4nf[2]/I:xttcnf[2]/I");
  if(TMath::Abs(steer.idgen)!=3) zdct->Branch("flowvar",&flowvar_t,"Qx[2]/D:Qy[2]/D");
  zdct->Branch("acc",&acc_t,"EventNum/I:ParticleNum/I:ParticleCode/I:IdCalo/I:iSide/I:kacc/I:pvx/D:pvy/D:pvz/D:pv/D:xvrt/D:yvrt/D:zvrt/D:xcalo/D:ycalo/D:uxcalo/D:uycalo/D:Enecalo/D");
  if(steer.ifl_newrdout!=0)  zdct->Branch("raw",&raw_t,"zn[24][5][2]/F:zp[24][5][2]/F:zem[24][2]:Charge_ZN[2]/F:Ampl_ZN[2]/F:Time_ZN[2]/F:SigmaTime_ZN[2]/F:Charge_ZP[2]/F:Ampl_ZP[2]/F:Time_ZP[2]/F:SigmaTime_ZP[2]/F");
    
  //prepare Fermi momentum if required
  if(steer.ifl_fermi==1) FermiTwoGaussian(steer.Aproj);

  // prepare background simulation if required
  //  particles hitting beampipe walls - two gaussians fit
  //  for protons: params from p0-5000_fromip_cor.root
  if(steer.ifl_bckgrnd==1) {
    fbckg1ZP->SetParameters(0.03024,0.07611,0.11, 0.02434,0.575,0.0543);
    fbckg1hZN->SetParameters(0.046,-0.023,0.104, 0.0282,0.424,0.065);
    //  next parameters from g0-4000_fromip.root (sfl=1) 
    //  see logbook_may2021.txt
    fbckg1emZN->SetParameters(0.0263,0.0803,0.0974, 0.0986,0.837,0.0471);
  }
  else if(steer.ifl_bckgrnd==2 || steer.ifl_bckgrnd==3) {
    fbckg = new TFile("bckgsimul.root");
    h6051 = (TH2F *)fbckg->Get("h5051");
    h6053 = (TH2F *)fbckg->Get("h5053");
    h6055 = (TH2F *)fbckg->Get("h5055");
    h6057 = (TH2F *)fbckg->Get("h5057");
    h7051 = (TH2F *)fbckg->Get("h3051");
    h7053 = (TH2F *)fbckg->Get("h3053");
    h7055 = (TH2F *)fbckg->Get("h3055");
    h7057 = (TH2F *)fbckg->Get("h3057");
    h7052 = (TH2F *)fbckg->Get("h3052");
    h7054 = (TH2F *)fbckg->Get("h3054");
    h7056 = (TH2F *)fbckg->Get("h3056");
    h7058 = (TH2F *)fbckg->Get("h3058"); 
  }

  //  open file where events from the generator are stored 
  if(TMath::Abs(steer.idgen)==1 || TMath::Abs(steer.idgen)==2 || TMath::Abs(steer.idgen)==6 || TMath::Abs(steer.idgen)==7) {
    fev=fopen(steer.HIJ_Filename, "r");
  }

  //if((steer.ifl_ip!=0) && (inibeam.zbeam>geom.distem[0])) {
  //  reading magnetic line for charged particles tracking
  rdlist();

  for(Int_t i=0; i<par_ele.num; i++) lost_ptl[i]=0;
  int TotalTracks = 0; 

  //  start loop over events
  Int_t evmax = steer.nevfrst + steer.nevmax;
    for(iev=steer.nevfrst; iev<evmax; iev++) {
      current.evnt = iev;
      if(current.evnt%steer.nevfreq==0) printf("\n ***** ev. %d\n",iev);
      fflush(stdout);

      // zero all structures (and variables) containing informations for the event
      memset(&gene_t,0,sizeof(gene_t));
      memset(&enzn_t,0,sizeof(enzn_t));
      memset(&ptlzn_t,0,sizeof(ptlzn_t));
      memset(&enzp_t,0,sizeof(enzp_t));
      memset(&ptlzp_t,0,sizeof(ptlzp_t));
      memset(&enzem_t,0,sizeof(enzem_t));
      memset(&ptlzem_t,0,sizeof(ptlzem_t));
      memset(&enexp_t,0,sizeof(enexp_t));
      memset(&phe_t,0,sizeof(phe_t));
      memset(&phenf_t,0,sizeof(phenf_t));
      memset(&flowvar_t,0,sizeof(flowvar_t));
      memset(&acc_t,0,sizeof(acc_t));
      if(steer.ifl_newrdout!=0) memset(&raw_t,0,sizeof(raw_t));
      
      readev();  //read one event

      // if idegen<0 tracking is disabled and the output tree is filled only with generator information
      if(steer.idgen<0) {
        zdct->Fill();
        continue; // tracking disabled
      }
      TotalTracks += ev1.natt; //count the total number of tracks in the restricted eta range
      
    //  define x,y,z of the production vertex from which every particle starts
    //  if required insert the broadening of vertex distribution (gaussian or uniform)
      Double_t zbip = 0.0;
      Double_t ybip = 0.0;
      Double_t xbip = 0.0;
      if(steer.ifl_ip==1){
        if(inibeam.ibeamfl==0){
          zbip = gRandom->Gaus(inibeam.zbeam, inibeam.dzbeam);
          ybip = gRandom->Gaus(inibeam.ybeam, inibeam.dybeam);
          xbip = gRandom->Gaus(inibeam.xbeam, inibeam.dxbeam);
        } else if(inibeam.ibeamfl==1){
          zbip = gRandom->Uniform(inibeam.zbeam-inibeam.dzbeam, inibeam.zbeam+inibeam.dzbeam);
          ybip = gRandom->Uniform(inibeam.ybeam-inibeam.dybeam, inibeam.ybeam+inibeam.dybeam);
          xbip = gRandom->Uniform(inibeam.xbeam-inibeam.dxbeam, inibeam.xbeam+inibeam.dxbeam);
        }
      }
      // store in structure the vertex coordinate for this event
      gene_t.vertex[0] = xbip;
      gene_t.vertex[1] = ybip;
      gene_t.vertex[2] = zbip;
    // find limits for geometrical acceptance for ZN to speed up code
    // we assume x coord of center of ZN placed on the beam line (x = 0.0) 
    // find limits for geometrical acceptance for ZN (no magfield) to speed up program
    Double_t ThxMaxZN = (TMath::Abs(geom.xczn[0])+geom.hxzn[0]+TMath::Abs(xbip))/(geom.distn[0]-zbip);
    Double_t ThyMaxZN = (TMath::Abs(geom.yczn[0])+geom.hyzn[0]+TMath::Abs(ybip))/(geom.distn[0]-zbip);
    Double_t ThxMinZN = (TMath::Abs(geom.xczn[0])-geom.hxzn[0]-TMath::Abs(xbip))/(geom.distn[0]-zbip);
    Double_t ThyMinZN = (TMath::Abs(geom.yczn[0])-geom.hyzn[0]-TMath::Abs(ybip))/(geom.distn[0]-zbip);

    /*if(iev%steer.nevfreq==0){
      printf(" Acceptance of ZN: max. thetax  = %f\n",ThxMaxZN);
      printf(" Acceptance of ZN: min. thetax  = %f\n",ThxMinZN);
      printf(" Acceptance of ZN: max. thetay  = %f\n",ThyMaxZN);
      printf(" Acceptance of ZN: min. thetay  = %f\n",ThyMinZN);
    }*/

    Int_t nTrack_0 = 0;
    Int_t nTrack_1 = 0;

    for(ip = 0; ip < ev1.natt; ip++) { //loop over particles
      //  define initial 4-mom (before crossing fermi or divergence can be applied)
      for (int i=0; i<=3; i++) pLab[i] = ev2.patt[i][ip];
      // find iside from sign of pz-coordinate
      if(pLab[2] < 0.0) {
        current.iside=1;
        nTrack_1++;
        continue;
      } else {
        current.iside=0;
        nTrack_0++;
      }
    
      // find out mass and charge from PDG code
      current.kPDGcode = ev2.katt[0][ip];
      TParticlePDG *part = db->GetParticle(current.kPDGcode);
      if(current.kPDGcode < 1000000) { 
        current.charge = part->Charge()/3.;
        mass = part->Mass();
      } else { // ion
          part = db->GetParticle(2212);
          protonmass = part->Mass();
          part = db->GetParticle(2112);
          neutronmass = part->Mass();
          double massp = current.charge*protonmass;
          double massn = (current.Anucl-current.charge)*neutronmass;
          mass = massp+massn;
          //printf("  ion charge = %f ",current.charge);
          //printf("  proton mass = %f\n",protonmass);
          //printf("  neutron mass = %f\n",neutronmass);
          //printf("  mass = %f\n",current.Anucl);
      }

      //skip the event if it is generated from FLUKA and it is hadronic collision
      if(TMath::Abs(steer.idgen) == 6 && ip==0 && ev2.katt[1][ip] > 0) break;  
      //skip the tracking if it is a fragment from FLUKA
      if(TMath::Abs(steer.idgen) == 6 && ev2.katt[1][ip] < 0) continue;  
      //  printf(" charge of the particle = %f\n",charge);
      
      // find out if particle can produce a em shower or not
      Int_t indem = 1; // particle is a hadron
      if(TMath::Abs(ev2.katt[0][ip])==22 || TMath::Abs(ev2.katt[0][ip])==11) indem=0;
      //define particle as spectator or participant
      current.partfl = kFALSE;  
      if(TMath::Abs(steer.idgen)==1 || TMath::Abs(steer.idgen)==2) {
        current.partfl = (ev2.katt[1][ip]!=0 && ev2.katt[1][ip]!=1 && ev2.katt[1][ip]!=10 && ev2.katt[1][ip]!=11);
      } else {
        current.partfl=kTRUE;
      }
      /*if(iev%steer.nevfreq==0){
      printf("particle no. %d : pLab = %f %f %f %f\n",ip,pLab[0],pLab[1],pLab[2],pLab[3]);
      printf("charge = %f\n",current.charge);
      if(current.partfl) { 
        printf(" particle no. %d is a participant\n",ip);
      } else {
        printf(" particle no. %d is a spectator nucleon\n",ip);
        printf(" mass = %f\n",mass);
      }
      }*/

      if(current.partfl){
        //if required apply crossing angle
        if(steer.ifl_cros==1) {
          for (Int_t i=0; i<=3; i++) fP[i]=pLab[i];
          //    printf("initial momentum components %f %f %f %f\n",fP[0],fP[1],fP[2],fP[3]);
          //    printf(" Beam Crossing: direct calculation for participant particles\n");    
          Double_t pbpern = TMath::Sqrt(steer.ebpern*steer.ebpern-protonmass*protonmass);
          Double_t du2 = 2.0*pbpern*TMath::Sin(inibeam.BeamCrossAngle);
          Double_t beta = du2/(2.0*steer.ebpern);
          Double_t gamma = 1./TMath::Sqrt(1.0-beta*beta);
          pLab[1] = gamma*(fP[1]+beta*fP[3]);
          pLab[3] = gamma*(fP[3]+beta*fP[1]);
          printf(" \n ++++]]]] Crossing angle applied \n\n");
          //    for(Int_t i=0; i<=3; i++)printf(" pLab[%d] = %f\n",i,pLab[i]);
        }
      }  
      else {
        for (Int_t i=0; i<4; i++) fP[i]=pLab[i];
        /*if(iev%steer.nevfreq==0) {
          printf(" particle no. %d is a spectator nucleon\n",ip);
          printf(" mass = %f\n",mass);
          printf(" 4mom before Fermi = %f %f %f %f\n",fP[0],fP[1],fP[2],fP[3]);
        }*/
        if(steer.ifl_fermi==1){
          ExtractFermi(1,ddp);

          Double_t fP0 = TMath::Sqrt(fP[0]*fP[0]+fP[1]*fP[1]+fP[2]*fP[2]+mass*mass);
          for(Int_t k=0; k<=2; k++) dddp[k] = ddp[k];
          dddp0 = TMath::Sqrt(dddp[0]*dddp[0]+dddp[1]*dddp[1]+dddp[2]*dddp[2]+mass*mass);
          TVector3 b(fP[0]/fP0, fP[1]/fP0, fP[2]/fP0);
          TLorentzVector pFermi(dddp[0], dddp[1], dddp[2], dddp0);
          //  boost refernce frame
          pFermi.Boost(b);
          for(Int_t k=0; k<=2; k++){
            //fBoostP[k] = pFermi[k];
            fP[k] = pFermi[k];
          }
          fP[3] = TMath::Sqrt(fP[0]*fP[0]+fP[1]*fP[1]+fP[2]*fP[2]+mass*mass);

          /*if(iev%steer.nevfreq==0) {
              printf(" particle no. %d\n",ip);
              printf(" mass = %f\n",mass);
              printf(" ddp = %f %f %f\n",ddp[0],ddp[1],ddp[2]);
              printf(" dddp0 = %f\n",dddp0);
              printf(" fP after Fermi = %f, %f, %f %f\n",fP[0],fP[1],fP[2],fP[3]);
          }*/

          for (Int_t i=0; i<=3; i++) pLab[i]=fP[i];
        }
        if(steer.ifl_cros==1) {
          // printf(" Beam Crossing: direct calculation for spectator nucleons\n");
          for (Int_t i=0; i<=3; i++) fP[i]=pLab[i];
          //      printf(" initial momentum components %f %f %f %f\n",fP[0],fP[1],fP[2],fP[3]);
          //  pLab[0] unchanged
          pLab[0]=fP[0];
          pLab[1]=fP[1]*TMath::Cos(inibeam.BeamCrossAngle)+fP[2]*TMath::Sin(inibeam.BeamCrossAngle);
          pLab[2]=-fP[1]*TMath::Sin(inibeam.BeamCrossAngle)+fP[2]*TMath::Cos(inibeam.BeamCrossAngle);
          //printf(" Particle momentum after crossing\n");
          //for(Int_t i=0; i<=2; i++)printf(" pLab[%d] = %f\n",i,pLab[i]);
        }
      }
      //  for all particles (either participants or spectators) apply beam 
      //  divergence if required
      if(steer.ifl_div==1) {
        for (Int_t i=0; i<=2; i++) fP[i]=pLab[i];
        pmq = 0.0;
        for(Int_t i=0; i<=2; i++) pmq = pmq+pLab[i]*pLab[i];
        //    Double_t pmod = TMath::Sqrt(pmq);
        pLab[3] = TMath::Sqrt(pmq+mass*mass); 
        fP[3]=pLab[3];
        //printf("initial 4-momentum components %f %f %f %f\n", fP[0], fP[1], fP[2], fP[3]);
        //printf(" Particle momentum before beam divergence\n");
        //for(Int_t i=0; i<=3; i++)printf(" [%d] = %f\n",i,pLab[i]);
        BeamDiv(pLab);
        //printf(" Particle momentum after divergence\n");
        //for(Int_t i=0; i<=3; i++) printf(" pLab[%d] = %f\n",i,pLab[i]);
      }
      KinVect[0] = xbip;
      KinVect[1] = ybip;
      KinVect[2] = zbip;
      for(Int_t i=0; i<4; i++) KinVect[i+3] = pLab[i];
      if(iev%steer.nevfreq==0){
        //printf(" --- Event no. %d   - particle no. %d\n",iev,ip);
        //printf(" PDG code = %d  -  charge = %f - source %d\n",current.kPDGcode,current.charge,ev2.katt[1][ip]);
        printf(" starting point = %f %f %f\n",xbip,ybip,zbip);
        printf("  4-mom = %f %f %f %f\n", pLab[0], pLab[1], pLab[2], pLab[3]);
      }
      Double_t thetax = KinVect[3]/KinVect[5];
      Double_t thetay = KinVect[4]/KinVect[5];
      Double_t dzem = geom.distem[0]-zbip;
      // find limits for geometrical acceptance for ZEM (no magfield) to speed up checkZEM
      // we assume ZEM symmetrical placed around beam line
      if(dzem >0.) {
        Double_t ThxMinZEM = (geom.xczem[0]-geom.hxzem[0]-xbip)/dzem;
        Double_t ThxMaxZEM = (geom.xczem[0]+geom.hxzem[0]-xbip)/dzem;
        Double_t ThyMinZEM = (geom.yczem[0]-geom.hyzem[0]-ybip)/dzem;
        Double_t ThyMaxZEM = (geom.yczem[0]+geom.hyzem[0]-ybip)/dzem;
        /*if(iev%steer.nevfreq==0){
          printf(" approx. acceptance of ZEM: max.thetax  = %f\n",ThxMaxZEM);
          printf(" approx. acceptance of ZEM: min.thetax  = %f\n",ThxMinZEM);
          printf(" approx. acceptance of ZEM: max.thetay  = %f\n",ThyMaxZEM);
          printf(" approx. acceptance of ZEM: min.thetay  = %f\n",ThyMinZEM);
        }*/
        //=====================================================================
        //  check ZEM for all the particles (charged and neutral particles)
        //  that are inside the geometrical acceptance
        //  kPDGcode = ev2.katt[0][ip];
        if(TMath::Abs(thetax)>ThxMinZEM && TMath::Abs(thetax)<ThxMaxZEM && TMath::Abs(thetay)>ThyMinZEM && TMath::Abs(thetay)<ThyMaxZEM && KinVect[5]>0.) {
        // check point of intersection of this track with ZEM
          checkZEM(KinVect); 
        }
      }
      //=====================================================================
      // to speed up the code: do not consider negative particles
      if(current.charge<0.0) continue; 
      // do not consider positive particles with a pz < 1 TeV/c
      //if(current.charge>0.0 && KinVect[5]<1000.0) continue; // commented by chiara...
      //
      // if neutral particles outside ZN acceptance they are not tracked
      //  printf("thetax = %f  -  thetay = %f\n",thetax,thetay);
      if(current.charge==0 && (thetax<ThxMinZN || thetax>ThxMaxZN || thetay<ThyMinZN || thetay>ThyMaxZN)) continue; 

      //=====================================================================
      // now make the tracking for neutral and positive particles through the 
      // elements
      // be careful that transverse coordinates are in mm directions in mrad !!
      //  transport particles up to first element directly
      oe = dynamic_cast<OpticEle*>(maglist.fElements->At(0));
      Double_t z = oe->GetZPos();
      //  delete first;
      //  printf(" z coordinate of first element = %f\n",z);
      Double_t dz = z-zbip;
      Double_t xfe = xbip+thetax*dz;  
      Double_t yfe = ybip+thetay*dz;  
      /*if(iev%steer.nevfreq==0){
        printf(" after first drift: x on first ele = %f - y on first ele = %f\n",xfe,yfe);
        printf(" after first drift: xprime = %f - yprime = %f\n",thetax,thetay);
      }*/
      lostflg = kFALSE;
      // Tracking works with coordinates in mm and mrad!!!! 
      (*xcoor)(0) = xfe*1000.;
      (*xcoor)(1) = pLab[0]/pLab[2]*1000.;
      (*ycoor)(0) = yfe*1000.;
      (*ycoor)(1) = pLab[1]/pLab[2]*1000.;
      //
      pmq = 0.;
      for(Int_t i=0; i<=2; i++) pmq = pmq+pLab[i]*pLab[i];
      Double_t pmod = TMath::Sqrt(pmq);
      Double_t mom = pmod;
      Double_t curz = z;

      if(iev%steer.nevfreq==0){
        //printf(" >>>  Event no. %d\n",iev);
        printf(" \n  Z/A = %f  ", current.ZoverA);
        printf(" momentum = %f GeV/c \n",mom);
        printf(" x, dx/dz = %f mm %f mrad\n",(*xcoor)(0),(*xcoor)(1));
        printf(" y, dy/dz = %f mm %f mrad\n",(*ycoor)(0),(*ycoor)(1));
        //printf(" starting at z = %f m - z primo elemento = %f\n",curz,z);
      }

      Int_t ilost = 0;
      //  TIter next(maglist.fElements);
      //  while((oe=dynamic_cast<OpticEle *>(next()))){
      for(Int_t kElement=0; kElement<maglist.fNoElements; kElement++) {
        oe = dynamic_cast<OpticEle*>(maglist.fElements->At(kElement));
        oe->SetZoverA(current.ZoverA);
        if(iev%steer.nevfreq==0){
          //oe->PrintStatus();
          printf("before element: x = %f, y =%f, z = %f ",(*xcoor)(0),(*ycoor)(0),curz);
          //printf("before element: dx/dz = %f, dy/dz =%f\n",(*xcoor)(1),(*ycoor)(1));
          cout<<"  z =  "<< curz << "m" << endl;  
        }
        if(current.charge == 0) {
          oe->Drift(xcoor, ycoor); 
        }
        else {
          oe->Propagate(xcoor, ycoor, mom); 
        }
        curz = oe->GetZPos()+oe->GetLength();
        if(iev%steer.nevfreq==0){
          printf("after element: x = %f, y =%f, z = %f ",(*xcoor)(0),(*ycoor)(0),curz);
          //printf("after element: dx/dz = %f, dy/dz =%f\n",(*xcoor)(1),(*ycoor)(1));
          cout<<"  z =  "<< curz << "m" << endl;  
        }
        Double_t xtr = (*xcoor)(0);
        Double_t ytr = (*ycoor)(0);
        Bool_t ap_type = oe->GetApertType();
        Double_t raddist = TMath::Sqrt(xtr*xtr+ytr*ytr);
        if(!ap_type) Double_t raddist = TMath::Abs(ytr);
        Double_t ap = oe->GetAperture1();
        /*if(iev%steer.nevfreq==0){
          printf("actual z position = %f\n",curz);
          printf("transverse radial position w.r.t. beam axis = %f\n",raddist);
          printf("radial aperture = %f\n",ap);
        }*/
        //fflush(stdout);
        if(raddist > ap) {
          ilost = kElement;
          lost_ptl[ilost]++;
          lostflg = kTRUE;
          break;
        }
      }  //end loop over elements
    
      if(lostflg) {
        if(iev%steer.nevfreq==0) {
          printf("particle lost in element no. %d:  up to now  = %d\n",ilost,lost_ptl[ilost]);
        }
        continue; // particle is lost before reaching ZDCs - continue loop over particle 
      }

      // check at the end of the tracking (on first face of ZDCs) position of
      // the particle on the transverse plane - to see if it is inside calos 
      //=====================================================================
      // check ZN 
      //printf(" \n .... before checkZN: x = %f, y =%f, z = %f\n", (*xcoor)(0), (*ycoor)(0), curz);
      KinVect[0] = (*xcoor)(0)/1000.;
      KinVect[1] = (*ycoor)(0)/1000.;
      KinVect[2] = curz;
      KinVect[3] = (*xcoor)(1)/1000.; //it is approximately correct
      KinVect[4] = (*ycoor)(1)/1000.; //it is approximately correct
      KinVect[5] = TMath::Sqrt(1.0-KinVect[3]*KinVect[3]-KinVect[4]*KinVect[4]);
      KinVect[6] = pLab[3];
      Double_t energy0 = KinVect[6];

      insideZN = checkZN(KinVect);
      //if(iev%steer.nevfreq==0 && insideZN) {
        if(insideZN) {
          printf(" +-+- pc in ZN >>  PDGcode = %d - charge = %f  ", current.kPDGcode, current.charge);
          printf(" x = %f, y = %f, z = %f\n", KinVect[0], KinVect[1], KinVect[2]);
          printf("  true energy = %f  -  energy in ZN = %f\n\n", enzn_t.etruezn[current.iside], enexp_t.ezn[current.iside]);
          //printf(" phe on PMC = %d \t",phe_t.qc[current.iside]);
          //printf(" phe on quadrants: Q1=%d, Q2=%d, Q3=%d, Q4=%d\n", phe_t.q1[current.iside], phe_t.q2[current.iside],phe_t.q3[current.iside],phe_t.q4[current.iside]);
        }
      //}
    
      //=====================================================================
      //check ZP
      insideZP = checkZP(KinVect);
      //if(iev%steer.nevfreq==0 && insideZP){
      if(insideZP){
        printf(" -+-+ pc in ZP >>  PDGcode = %d - charge = %f \n", current.kPDGcode, current.charge);
        printf(" x =%f, y =%f, z =%f\n", KinVect[0], KinVect[1], KinVect[2]);
        printf(" true energy = %f  -  energy in ZP = %f  - phe on PMC = %d\n\n", enzp_t.etruezp[current.iside],enexp_t.ezp[current.iside],phe_t.tc[current.iside]);
        //printf(" phe on PMC = %d \t", phe_t.tc[current.iside]);
        //printf(" phe on towers: T1=%d, T2=%d, T3=%d, T4=%d\n", phe_t.t1[current.iside], phe_t.t2[current.iside],phe_t.t3[current.iside],phe_t.t4[current.iside]);
      }

      if(steer.idgen == 3) {
        if(insideZN || insideZP) { // scrivo acc_t vars ONLY IF particle is inside ZN or ZP!!!!! (chiara)
          acc_t.EventNum = iev;
          acc_t.ParticleNum = ip;
          acc_t.ParticleCode = current.kPDGcode;
          if(insideZN) acc_t.IdCalo = 1;
          else if(insideZP) acc_t.IdCalo = 2;
          acc_t.iSide = current.iside;
          acc_t.kacc = 0;
          acc_t.kacc = 1; 
          acc_t.pvx = pLab[0];
          acc_t.pvy = pLab[1];
          acc_t.pvz = pLab[2];
          acc_t.pv = pLab[3];
          acc_t.xvrt = xbip;
          acc_t.yvrt = ybip;
          acc_t.zvrt = zbip;
          acc_t.xcalo = KinVect[0];
          acc_t.ycalo = KinVect[1];
          acc_t.uxcalo = KinVect[3];
          acc_t.uycalo = KinVect[4];
          acc_t.Enecalo = KinVect[6];
          if(iev%steer.nevfreq==0){
            printf(" ** ACC. ev. %d - pc %d - PDG code %d\n",iev, ip, current.kPDGcode);
            printf(" side %d - acceptance flag = %d\n",acc_t.iSide, acc_t.kacc);
            printf(" pvx = %f - pvy = %f - pvz = %f - pv = %f\n",acc_t.pvx,acc_t.pvy,acc_t.pvz,acc_t.pv);
            //printf(" vertex coord.: x = %f - y = %f - z = %f\n",acc_t.xvrt,acc_t.yvrt,acc_t.zvrt);
            printf(" x on calo = %f  -  y on calo = %f\n",100*acc_t.xcalo,100*acc_t.ycalo);
            //printf(" ux on calo = %f  -  uy on calo = %f\n",acc_t.uxcalo,acc_t.uycalo);
            printf(" energy on calo = %f\n\n",acc_t.Enecalo);
          }
        } // se pc inside ZN || ZP
        else {
          acc_t.EventNum = iev;
          acc_t.ParticleNum = -1;
          acc_t.ParticleCode = -1;
          acc_t.IdCalo = -1;
          acc_t.iSide = -1;
          acc_t.kacc = -1;
          acc_t.kacc = -1; 
          acc_t.pvx = -1;
          acc_t.pvy = -1;
          acc_t.pvz = -1;
          acc_t.pv = -1;
          acc_t.xvrt = -1;
          acc_t.yvrt = -1;
          acc_t.zvrt = -1;
          acc_t.xcalo = -1;
          acc_t.ycalo = -1;
          acc_t.uxcalo = -1;
          acc_t.uycalo = -1;
          acc_t.Enecalo = -1;
        }
      }
      if((!insideZN) && (!insideZP) && (steer.ifl_bckgrnd == 2)) {
        Double_t x = KinVect[0]*100.; // from m to cm
        Double_t y = KinVect[1]*100.;
        Double_t z = KinVect[2]*100.;
        /*if(iev%steer.nevfreq==0){
          printf(" particle at ZDC location - x =%f, y =%f, z =%f\n",x,y,z);
          printf(" with ux = %f - uy = %f - uz = %f \n",KinVect[3],KinVect[4],KinVect[5]);
          printf(" true energy = %f\n", energy0);
          printf(" current participant flag = %d - current particle PDG = %d\n",current.partfl,current.kPDGcode);
          printf(" background is considered\n");
        }*/
        Double_t phebckgzn[5] = {0.,};
        Double_t phebckgzp[5] = {0.,};
        Double_t prob_bckg = gRandom->Uniform(0.,1.);
        Double_t bckg_cont = 0.;
        Int_t bin_bckg = 0;
        Double_t phe_contzn = 0.;
        Double_t phe_bckgzn = 0.;
        Double_t phe_contzp = 0.;
        Double_t phe_bckgzp = 0.;
        if(!current.partfl && current.kPDGcode==2112) {
          bin_bckg = h6051->FindBin(x,y);
          bckg_cont = h6051->GetBinContent(bin_bckg);
          if(iev%steer.nevfreq==0){
            printf(" particle type: neutron\n");
            printf(" random number = %f\n",prob_bckg);
            printf(" bckg: x = %f - y = %f\n",x,y);
            printf(" bin number = %d\n",bin_bckg);
            printf(" bin content = %f\n",bckg_cont);
          }
          if(prob_bckg < bckg_cont) {
            phe_contzn = h7051->GetBinContent(bin_bckg);
            phe_bckgzn = phe_contzn * energy0;
            phe_contzp = h7052->GetBinContent(bin_bckg);
            phe_bckgzp = phe_contzp * energy0;
            if(iev%steer.nevfreq==0){
                printf(" bckg: phe in ZN (phe_bckgzn) = %f\n",phe_bckgzn);
                printf(" bckg: phe in ZP (phe_bckgzp) = %f\n",phe_bckgzp);
            }
          }
        } else if(!current.partfl && current.kPDGcode==2212){
            bin_bckg = h6053->FindBin(x,y);
            bckg_cont = h6053->GetBinContent(bin_bckg);
            if(iev%steer.nevfreq==0){
              printf(" particle type: proton\n");
              printf(" random number = %f\n",prob_bckg);
              printf(" bckg: x = %f - y = %f\n",x,y);
              printf(" bin number = %d\n",bin_bckg);
              printf(" bin content = %f\n",bckg_cont);
            }
            if(prob_bckg < bckg_cont) {
              phe_contzn = h7053->GetBinContent(bin_bckg);
              phe_bckgzn = phe_contzn * energy0;
              phe_contzp = h7054->GetBinContent(bin_bckg);
              phe_bckgzp = phe_contzp * energy0;
              if(iev%steer.nevfreq==0){
                printf(" bckg: phe in ZN (phe_bckgzn) = %f\n",phe_bckgzn);
                printf(" bckg: phe in ZP (phe_bckgzp) = %f\n",phe_bckgzp);
              }
            }
        } else if(current.partfl && current.charge!=0) {
            bin_bckg = h6055->FindBin(x,y);
            bckg_cont = h6055->GetBinContent(bin_bckg);
            if(iev%steer.nevfreq==0){
              printf(" particle type: charged particle\n");
              printf(" random number = %f\n",prob_bckg);
              printf(" bckg: x = %f - y = %f\n",x,y);
              printf(" bin number = %d\n",bin_bckg);
              printf(" bin content = %f\n",bckg_cont);
            }
            if(prob_bckg < bckg_cont) {
              phe_contzn = h7055->GetBinContent(bin_bckg);
              phe_bckgzn = phe_contzn * energy0;
              phe_contzp = h7056->GetBinContent(bin_bckg);
              phe_bckgzp = phe_contzp * energy0;
              if(iev%steer.nevfreq==0){
                printf(" bckg: phe in ZN (phe_bckgzn) = %f\n",phe_bckgzn);
                printf(" bckg: phe in ZP (phe_bckgzp) = %f\n",phe_bckgzp);
              }
            }
        } else if(current.kPDGcode==22) {
            bin_bckg = h6057->FindBin(x,y);
            bckg_cont = h6057->GetBinContent(bin_bckg);
            if(iev%steer.nevfreq==0){
              printf(" particle type: gamma\n");
              printf(" random number = %f\n",prob_bckg);
              printf(" bckg: x = %f - y = %f\n",x,y);
              printf(" bin number = %d\n",bin_bckg);
              printf(" bin content = %f\n",bckg_cont);
            }
            if(prob_bckg < bckg_cont) {
              phe_contzn = h7057->GetBinContent(bin_bckg);
              phe_bckgzn = phe_contzn * energy0;
              printf(" bckg: phe in ZN (phe_bckgzn) = %f\n",phe_bckgzn);
              phe_contzp = h7058->GetBinContent(bin_bckg);
              phe_bckgzp = phe_contzp * energy0;
                    if(iev%steer.nevfreq==0){
              printf(" bckg: phe in ZN (phe_bckgzn) = %f\n",phe_bckgzn);
              printf(" bckg: phe in ZP (phe_bckgzp) = %f\n",phe_bckgzp);
              }
            }
        }
        if(phe_bckgzn > 0.) {
          phebckgzn[0] = 0.5*phe_bckgzn;
          Double_t q1q3n = fnbckgzn[0]+fnbckgzn[1]*atan(fnbckgzn[2]*(KinVect[0]+fnbckgzn[3]));
          q1q3n *= phebckgzn[0];
          Double_t q2q4n = phebckgzn[0]-q1q3n;
          phebckgzn[1] = q1q3n *0.5;
          phebckgzn[3] = q1q3n *0.5;
          phebckgzn[2] = q2q4n *0.5;
          phebckgzn[4] = q2q4n *0.5;
          if(iev%steer.nevfreq==0){
              printf(" bckg: phe in ZN towers\n");
              printf(" q1 = %f - q3 = %f\n",phebckgzn[1],phebckgzn[3]);
              printf(" q2 = %f - q4 = %f\n",phebckgzn[2],phebckgzn[4]);
              printf(" bckg: phe in ZP towers\n");
          }
          phebckgzp[0] = 0.5*phe_bckgzp;
          Double_t rattower;
          for(Int_t jj=1; jj<5; jj++){
            rattower=fnbckgzp0[jj-1]+fnbckgzp1[jj-1]*KinVect[0];
            phebckgzp[jj]=phebckgzp[0]*rattower;
            if(iev%steer.nevfreq==0) printf(" phebckgzp[%d] = %f\n",jj,phebckgzp[jj]);
          }
          //  update the number of phe adding the phe due to background
            phe_t.qc[current.iside] += TMath::Nint(phebckgzn[0]);
            phe_t.q1[current.iside] += TMath::Nint(phebckgzn[1]);
            phe_t.q2[current.iside] += TMath::Nint(phebckgzn[2]);
            phe_t.q3[current.iside] += TMath::Nint(phebckgzn[3]);
            phe_t.q4[current.iside] += TMath::Nint(phebckgzn[4]);
            phe_t.tc[current.iside] += TMath::Nint(phebckgzp[0]);
            phe_t.t1[current.iside] += TMath::Nint(phebckgzp[1]);
            phe_t.t2[current.iside] += TMath::Nint(phebckgzp[2]);
            phe_t.t3[current.iside] += TMath::Nint(phebckgzp[3]);
            phe_t.t4[current.iside] += TMath::Nint(phebckgzp[4]);
        } else {
        if(iev%steer.nevfreq==0) printf(" no photoelectrons produced in naked fibres\n");
      }
      }
    }  //end loop over particles

    //  if(TMath::Abs(steer.idgen)==6 && ip==0 && ev2.katt[1][ip] >0) continue;  
     /*if(iev%steer.nevfreq==0) {
       printf(" impact parameter b = %f\n",gene_t.bimp);
       printf(" numero totale pc prodotte = %d\n",gene_t.prod_ptl);
       printf(" produced part. with eta>4 = %d\n",gene_t.cons_ptl);
       printf(" number of tracks side A = %d\n",nTrack_0);
       printf(" number of tracks side C = %d\n",nTrack_1);
       printf(" reaction plane angle = %f\n",gene_t.psi_react_plane);
       printf(" free n = %d  -  free p = %d\n",gene_t.nf[0],gene_t.pf[0]);
       printf(" true energy nspect in ZN = %f\n",enzn_t.espnzn[0]);
       printf(" true energy npart in ZN = %f\n",enzn_t.eprnzn[0]);
       printf(" true energy pspect in ZN = %f\n",enzn_t.esppzn[0]);
       printf(" true energy ppart in ZN = %f\n",enzn_t.eprpzn[0]);
       printf(" true energy gammas in ZN = %f\n",enzn_t.egamzn[0]);
       printf(" true energy in ZN = %f\n",enzn_t.etruezn[0]);
       printf(" exp. energy in ZN = %f\n\n",enexp_t.ezn[0]);
     }*/  

      //  Int_t ismax = 1;
      Int_t ismax = 2;
      bool isFragment = false;
      if(current.kPDGcode > 1000000) isFragment = true;
      if((steer.idgen==3) || (steer.idgen==4)) ismax = 1;
      for(Int_t is=0; is<ismax; is++){  //loop over iside
        FindCentroid(is, isFragment, current.Anucl);
        FindFlowQ(is);
        if(is == 0) SwapTowers();
        if(steer.ifl_newrdout!=0) rawSignals(is);
      }  //end loop over iside
 
      //=====================================================================
      //  fill tree
      zdct->Fill();
  
    } //end loop over events

    delete oe;
    delete xcoor;
    delete ycoor;

   printf("\n Total number of events = %d\n",iev);
   //printf("  Total number of tracks in the selected eta range = %d\n",TotalTracks);
   for(Int_t i=0; i<par_ele.num; i++) {
     Double_t pcloss = (Double_t)lost_ptl[i]/(Double_t)TotalTracks;
     printf("   line element no. %d -> particles lost = %d  %f perc. \n",i,lost_ptl[i],pcloss);
   }
  
  if (TMath::Abs(steer.idgen)==5) femd->Close();
  
  fot->cd();
  zdct->Write();
  fot->Close();
  //  gObjectTable->Print();
  t.Stop();
  t.Print();
  return 0;
}
